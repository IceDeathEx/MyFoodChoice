{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar DEFAULT_TIMEOUT = 3000;\nvar INIT_ID = 0;\nvar EVENT_CLOSED = 'closed';\nvar EVENT_DRAINED = 'drained';\n\n/**\n * Instance a new queue\n *\n * @param {Number} timeout a global timeout for new queue\n * @class\n * @constructor\n */\nvar SeqQueue = function (timeout) {\n  EventEmitter.call(this);\n  if (timeout && timeout > 0) {\n    this.timeout = timeout;\n  } else {\n    this.timeout = DEFAULT_TIMEOUT;\n  }\n  this.status = SeqQueueManager.STATUS_IDLE;\n  this.curId = INIT_ID;\n  this.queue = [];\n};\nutil.inherits(SeqQueue, EventEmitter);\n\n/**\n * Add a task into queue.\n * \n * @param fn new request\n * @param ontimeout callback when task timeout\n * @param timeout timeout for current request. take the global timeout if this is invalid\n * @returns true or false\n */\nSeqQueue.prototype.push = function (fn, ontimeout, timeout) {\n  if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n    //ignore invalid status\n    return false;\n  }\n  if (typeof fn !== 'function') {\n    throw new Error('fn should be a function.');\n  }\n  this.queue.push({\n    fn: fn,\n    ontimeout: ontimeout,\n    timeout: timeout\n  });\n  if (this.status === SeqQueueManager.STATUS_IDLE) {\n    this.status = SeqQueueManager.STATUS_BUSY;\n    var self = this;\n    process.nextTick(function () {\n      self._next(self.curId);\n    });\n  }\n  return true;\n};\n\n/**\n * Close queue\n * \n * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue\n */\nSeqQueue.prototype.close = function (force) {\n  if (this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n    //ignore invalid status\n    return;\n  }\n  if (force) {\n    this.status = SeqQueueManager.STATUS_DRAINED;\n    if (this.timerId) {\n      clearTimeout(this.timerId);\n      this.timerId = undefined;\n    }\n    this.emit(EVENT_DRAINED);\n  } else {\n    this.status = SeqQueueManager.STATUS_CLOSED;\n    this.emit(EVENT_CLOSED);\n  }\n};\n\n/**\n * Invoke next task\n * \n * @param {String|Number} tid last executed task id\n * @api private\n */\nSeqQueue.prototype._next = function (tid) {\n  if (tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {\n    //ignore invalid next call\n    return;\n  }\n  if (this.timerId) {\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n  }\n  var task = this.queue.shift();\n  if (!task) {\n    if (this.status === SeqQueueManager.STATUS_BUSY) {\n      this.status = SeqQueueManager.STATUS_IDLE;\n      this.curId++; //modify curId to invalidate timeout task\n    } else {\n      this.status = SeqQueueManager.STATUS_DRAINED;\n      this.emit(EVENT_DRAINED);\n    }\n    return;\n  }\n  var self = this;\n  task.id = ++this.curId;\n  var timeout = task.timeout > 0 ? task.timeout : this.timeout;\n  timeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;\n  this.timerId = setTimeout(function () {\n    process.nextTick(function () {\n      self._next(task.id);\n    });\n    self.emit('timeout', task);\n    if (task.ontimeout) {\n      task.ontimeout();\n    }\n  }, timeout);\n  try {\n    task.fn({\n      done: function () {\n        var res = task.id === self.curId;\n        process.nextTick(function () {\n          self._next(task.id);\n        });\n        return res;\n      }\n    });\n  } catch (err) {\n    self.emit('error', err, task);\n    process.nextTick(function () {\n      self._next(task.id);\n    });\n  }\n};\n\n/**\n * Queue manager.\n * \n * @module\n */\nvar SeqQueueManager = module.exports;\n\n/**\n * Queue status: idle, welcome new tasks\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_IDLE = 0;\n\n/**\n * Queue status: busy, queue is working for some tasks now\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_BUSY = 1;\n\n/**\n * Queue status: closed, queue has closed and would not receive task any more \n * \t\t\t\t\tand is processing the remaining tasks now.\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_CLOSED = 2;\n\n/**\n * Queue status: drained, queue is ready to be destroy\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_DRAINED = 3;\n\n/**\n * Create Sequence queue\n * \n * @param  {Number} timeout a global timeout for the new queue instance\n * @return {Object}         new queue instance\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.createQueue = function (timeout) {\n  return new SeqQueue(timeout);\n};","map":{"version":3,"names":["EventEmitter","require","util","DEFAULT_TIMEOUT","INIT_ID","EVENT_CLOSED","EVENT_DRAINED","SeqQueue","timeout","call","status","SeqQueueManager","STATUS_IDLE","curId","queue","inherits","prototype","push","fn","ontimeout","STATUS_BUSY","Error","self","process","nextTick","_next","close","force","STATUS_DRAINED","timerId","clearTimeout","undefined","emit","STATUS_CLOSED","tid","task","shift","id","setTimeout","done","res","err","module","exports","createQueue"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/seq-queue/lib/seq-queue.js"],"sourcesContent":["var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar DEFAULT_TIMEOUT = 3000;\nvar INIT_ID = 0;\nvar EVENT_CLOSED = 'closed';\nvar EVENT_DRAINED = 'drained';\n\n/**\n * Instance a new queue\n *\n * @param {Number} timeout a global timeout for new queue\n * @class\n * @constructor\n */\nvar SeqQueue = function(timeout) {\n\tEventEmitter.call(this);\n\t\n\tif(timeout && timeout > 0) {\n\t\tthis.timeout = timeout;\n\t} else {\n\t\tthis.timeout = DEFAULT_TIMEOUT;\n\t}\n\t\n\tthis.status = SeqQueueManager.STATUS_IDLE;\n\tthis.curId = INIT_ID;\n\tthis.queue = [];\n};\nutil.inherits(SeqQueue, EventEmitter);\n\n/**\n * Add a task into queue.\n * \n * @param fn new request\n * @param ontimeout callback when task timeout\n * @param timeout timeout for current request. take the global timeout if this is invalid\n * @returns true or false\n */\nSeqQueue.prototype.push = function(fn, ontimeout, timeout) {\n\tif(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n\t\t//ignore invalid status\n\t\treturn false;\n\t}\n\t\n\tif(typeof fn !== 'function') {\n\t\tthrow new Error('fn should be a function.');\n\t}\n\tthis.queue.push({fn: fn, ontimeout: ontimeout, timeout: timeout});\n\n\tif(this.status === SeqQueueManager.STATUS_IDLE) {\n\t\tthis.status = SeqQueueManager.STATUS_BUSY;\n\t\tvar self = this;\n\t\tprocess.nextTick(function() {\n\t\t\tself._next(self.curId);\n\t\t});\n\t}\n\treturn true;\n};\n\n/**\n * Close queue\n * \n * @param {Boolean} force if true will close the queue immediately else will execute the rest task in queue\n */\nSeqQueue.prototype.close = function(force) {\n\tif(this.status !== SeqQueueManager.STATUS_IDLE && this.status !== SeqQueueManager.STATUS_BUSY) {\n\t\t//ignore invalid status\n\t\treturn;\n\t}\n\t\n\tif(force) {\n\t\tthis.status = SeqQueueManager.STATUS_DRAINED;\n\t\tif(this.timerId) {\n\t\t\tclearTimeout(this.timerId);\n\t\t\tthis.timerId = undefined;\n\t\t}\n\t\tthis.emit(EVENT_DRAINED);\n\t} else {\n\t\tthis.status = SeqQueueManager.STATUS_CLOSED;\n\t\tthis.emit(EVENT_CLOSED);\n\t}\n};\n\n/**\n * Invoke next task\n * \n * @param {String|Number} tid last executed task id\n * @api private\n */\nSeqQueue.prototype._next = function(tid) {\n\tif(tid !== this.curId || this.status !== SeqQueueManager.STATUS_BUSY && this.status !== SeqQueueManager.STATUS_CLOSED) {\n\t\t//ignore invalid next call\n\t\treturn;\n\t}\n\t\n\tif(this.timerId) {\n\t\tclearTimeout(this.timerId);\n\t\tthis.timerId = undefined;\n\t}\n\t\n\tvar task = this.queue.shift();\n\tif(!task) {\n\t\tif(this.status === SeqQueueManager.STATUS_BUSY) {\n\t\t\tthis.status = SeqQueueManager.STATUS_IDLE;\n\t\t\tthis.curId++;\t//modify curId to invalidate timeout task\n\t\t} else {\n\t\t\tthis.status = SeqQueueManager.STATUS_DRAINED;\n\t\t\tthis.emit(EVENT_DRAINED);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tvar self = this;\n\ttask.id = ++this.curId;\n\n\tvar timeout = task.timeout > 0 ? task.timeout : this.timeout;\n\ttimeout = timeout > 0 ? timeout : DEFAULT_TIMEOUT;\n\tthis.timerId = setTimeout(function() {\n\t\tprocess.nextTick(function() {\n\t\t\tself._next(task.id);\n\t\t});\n\t\tself.emit('timeout', task);\n\t\tif(task.ontimeout) {\n\t\t\ttask.ontimeout();\n\t\t}\n\t}, timeout);\n\n\ttry {\n\t\ttask.fn({\n\t\t\tdone: function() {\n\t\t\t\tvar res = task.id === self.curId;\n\t\t\t\tprocess.nextTick(function() {\n\t\t\t\t\tself._next(task.id);\n\t\t\t\t});\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t} catch(err) {\n\t\tself.emit('error', err, task);\n\t\tprocess.nextTick(function() {\n\t\t\tself._next(task.id);\n\t\t});\n\t}\n};\n\n/**\n * Queue manager.\n * \n * @module\n */\nvar SeqQueueManager = module.exports;\n\n/**\n * Queue status: idle, welcome new tasks\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_IDLE = 0;\n\n/**\n * Queue status: busy, queue is working for some tasks now\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_BUSY = 1;\n\n/**\n * Queue status: closed, queue has closed and would not receive task any more \n * \t\t\t\t\tand is processing the remaining tasks now.\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_CLOSED = 2; \n\n/**\n * Queue status: drained, queue is ready to be destroy\n *\n * @const\n * @type {Number}\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.STATUS_DRAINED = 3;\n\n/**\n * Create Sequence queue\n * \n * @param  {Number} timeout a global timeout for the new queue instance\n * @return {Object}         new queue instance\n * @memberOf SeqQueueManager\n */\nSeqQueueManager.createQueue = function(timeout) {\n\treturn new SeqQueue(timeout);\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}