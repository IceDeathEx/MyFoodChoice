{"ast":null,"code":"// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n  length() {\n    return this.end - this.start;\n  }\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log([this.buffer.asciiSlice(this.start, this.end)], this.buffer.slice(this.start, this.end), this.length(), this.sequenceId);\n  }\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n  skip(num) {\n    this.offset += num;\n  }\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T');\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[leftPad(2, H), leftPad(2, M), leftPad(2, S)].join(':')}`;\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])\n    // For positive times below 24 hours, this makes it equal to ISO 8601 times\n    return (sign === -1 ? '-' : '') + [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') + (ms ? `.${ms}`.replace(/0+$/, '') : '');\n  }\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);\n  }\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer, encoding, start, end);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(this.buffer, encoding, this.offset - len, this.offset);\n  }\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1:\n          // WKBPoint\n          x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = {\n            x: x,\n            y: y\n          };\n          break;\n        case 2:\n          // WKBLineString\n          numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({\n              x: x,\n              y: y\n            });\n          }\n          break;\n        case 3:\n          // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder ? buffer.readDoubleLE(offset) : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({\n                x: x,\n                y: y\n              });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7:\n          // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder ? buffer.readUInt32LE(offset) : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(`${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`);\n  }\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return result / factor * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset = (timezone[0] === '-' ? -1 : 1) * (parseInt(timezone.substring(1, 3), 10) * 60 + parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n\n    return '';\n  }\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n  static MockBuffer() {\n    const noop = function () {};\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\nmodule.exports = Packet;","map":{"version":3,"names":["ErrorCodeToName","require","NativeBuffer","Buffer","Long","StringParser","INVALID_DATE","Date","NaN","pad","leftPad","num","value","s","toString","length","slice","minus","charCodeAt","plus","dot","exponent","exponentCapital","Packet","constructor","id","buffer","start","end","sequenceId","numPackets","offset","reset","dump","console","log","asciiSlice","haveMoreData","skip","readInt8","readInt16","readUInt16LE","readInt24","readInt32","readUInt32LE","readSInt8","readSInt16","readInt16LE","readSInt32","readInt32LE","readInt64JSNumber","word0","word1","l","toNumber","readSInt64JSNumber","readInt64String","res","readSInt64String","readInt64","resNumber","resString","readSInt64","isEOF","eofStatusFlags","eofWarningCount","readLengthCodedNumber","bigNumberStrings","signed","byte1","readLengthCodedNumberExt","readLengthCodedNumberSigned","tag","trace","Error","readFloat","readFloatLE","readDouble","readDoubleLE","readBuffer","len","readDateTime","timezone","y","m","d","H","M","S","ms","UTC","str","readDateTimeString","decimals","timeSep","join","substring","readTimeString","convertTtoMs","sign","replace","readLengthCodedString","encoding","decode","readLengthCodedBuffer","readNullTerminatedString","readString","undefined","parseInt","supportBigNumbers","Number","result","numDigits","parseIntNoBigCheck","parseGeometryValue","parseGeometry","x","i","j","numPoints","line","byteOrder","readUInt8","wkbType","readUInt32BE","readDoubleBE","push","numRings","parseDate","strLen","parseDateTime","parseFloat","factor","pastDot","charCode","exponentValue","Math","pow","parseLengthCodedIntNoBigCheck","parseLengthCodedInt","parseLengthCodedIntString","parseLengthCodedFloat","peekByte","isAlt","isError","asError","errorCode","sqlState","message","err","code","errno","sqlMessage","writeInt32","n","writeUInt32LE","writeInt24","writeInt8","writeInt16","writeUInt16LE","writeUInt8","writeDouble","writeDoubleLE","writeBuffer","b","copy","writeNull","writeNullTerminatedString","buf","encode","writeString","writeLengthCodedString","writeLengthCodedNumber","writeLengthCodedBuffer","writeDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","writeHeader","clone","type","lengthCodedNumberLength","lengthCodedStringLength","slen","MockBuffer","noop","alloc","op","prototype","module","exports"],"sources":["C:/Users/runes/FYP/myfoodchoice/node_modules/mysql2/lib/packets/packet.js"],"sourcesContent":["// This file was modified by Oracle on June 1, 2021.\n// A comment describing some changes in the strict default SQL mode regarding\n// non-standard dates was introduced.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst ErrorCodeToName = require('../constants/errors.js');\nconst NativeBuffer = require('buffer').Buffer;\nconst Long = require('long');\nconst StringParser = require('../parsers/string.js');\n\nconst INVALID_DATE = new Date(NaN);\n\n// this is nearly duplicate of previous function so generated code is not slower\n// due to \"if (dateStrings)\" branching\nconst pad = '000000000000';\nfunction leftPad(num, value) {\n  const s = value.toString();\n  // if we don't need to pad\n  if (s.length >= num) {\n    return s;\n  }\n  return (pad + s).slice(-num);\n}\n\n// The whole reason parse* function below exist\n// is because String creation is relatively expensive (at least with V8), and if we have\n// a buffer with \"12345\" content ideally we would like to bypass intermediate\n// \"12345\" string creation and directly build 12345 number out of\n// <Buffer 31 32 33 34 35> data.\n// In my benchmarks the difference is ~25M 8-digit numbers per second vs\n// 4.5 M using Number(packet.readLengthCodedString())\n// not used when size is close to max precision as series of *10 accumulate error\n// and approximate result mihgt be diffreent from (approximate as well) Number(bigNumStringValue))\n// In the futire node version if speed difference is smaller parse* functions might be removed\n// don't consider them as Packet public API\n\nconst minus = '-'.charCodeAt(0);\nconst plus = '+'.charCodeAt(0);\n\n// TODO: handle E notation\nconst dot = '.'.charCodeAt(0);\nconst exponent = 'e'.charCodeAt(0);\nconst exponentCapital = 'E'.charCodeAt(0);\n\nclass Packet {\n  constructor(id, buffer, start, end) {\n    // hot path, enable checks when testing only\n    // if (!Buffer.isBuffer(buffer) || typeof start == 'undefined' || typeof end == 'undefined')\n    //  throw new Error('invalid packet');\n    this.sequenceId = id;\n    this.numPackets = 1;\n    this.buffer = buffer;\n    this.start = start;\n    this.offset = start + 4;\n    this.end = end;\n  }\n\n  // ==============================\n  // readers\n  // ==============================\n  reset() {\n    this.offset = this.start + 4;\n  }\n\n  length() {\n    return this.end - this.start;\n  }\n\n  slice() {\n    return this.buffer.slice(this.start, this.end);\n  }\n\n  dump() {\n    // eslint-disable-next-line no-console\n    console.log(\n      [this.buffer.asciiSlice(this.start, this.end)],\n      this.buffer.slice(this.start, this.end),\n      this.length(),\n      this.sequenceId\n    );\n  }\n\n  haveMoreData() {\n    return this.end > this.offset;\n  }\n\n  skip(num) {\n    this.offset += num;\n  }\n\n  readInt8() {\n    return this.buffer[this.offset++];\n  }\n\n  readInt16() {\n    this.offset += 2;\n    return this.buffer.readUInt16LE(this.offset - 2);\n  }\n\n  readInt24() {\n    return this.readInt16() + (this.readInt8() << 16);\n  }\n\n  readInt32() {\n    this.offset += 4;\n    return this.buffer.readUInt32LE(this.offset - 4);\n  }\n\n  readSInt8() {\n    return this.buffer.readInt8(this.offset++);\n  }\n\n  readSInt16() {\n    this.offset += 2;\n    return this.buffer.readInt16LE(this.offset - 2);\n  }\n\n  readSInt32() {\n    this.offset += 4;\n    return this.buffer.readInt32LE(this.offset - 4);\n  }\n\n  readInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const l = new Long(word0, word1, true);\n    return l.toNumber();\n  }\n\n  readSInt64JSNumber() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    if (!(word1 & 0x80000000)) {\n      return word0 + 0x100000000 * word1;\n    }\n    const l = new Long(word0, word1, false);\n    return l.toNumber();\n  }\n\n  readInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, true);\n    return res.toString();\n  }\n\n  readSInt64String() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    const res = new Long(word0, word1, false);\n    return res.toString();\n  }\n\n  readInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, true);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  readSInt64() {\n    const word0 = this.readInt32();\n    const word1 = this.readInt32();\n    let res = new Long(word0, word1, false);\n    const resNumber = res.toNumber();\n    const resString = res.toString();\n    res = resNumber.toString() === resString ? resNumber : resString;\n    return res;\n  }\n\n  isEOF() {\n    return this.buffer[this.offset] === 0xfe && this.length() < 13;\n  }\n\n  eofStatusFlags() {\n    return this.buffer.readInt16LE(this.offset + 3);\n  }\n\n  eofWarningCount() {\n    return this.buffer.readInt16LE(this.offset + 1);\n  }\n\n  readLengthCodedNumber(bigNumberStrings, signed) {\n    const byte1 = this.buffer[this.offset++];\n    if (byte1 < 251) {\n      return byte1;\n    }\n    return this.readLengthCodedNumberExt(byte1, bigNumberStrings, signed);\n  }\n\n  readLengthCodedNumberSigned(bigNumberStrings) {\n    return this.readLengthCodedNumber(bigNumberStrings, true);\n  }\n\n  readLengthCodedNumberExt(tag, bigNumberStrings, signed) {\n    let word0, word1;\n    let res;\n    if (tag === 0xfb) {\n      return null;\n    }\n    if (tag === 0xfc) {\n      return this.readInt8() + (this.readInt8() << 8);\n    }\n    if (tag === 0xfd) {\n      return this.readInt8() + (this.readInt8() << 8) + (this.readInt8() << 16);\n    }\n    if (tag === 0xfe) {\n      // TODO: check version\n      // Up to MySQL 3.22, 0xfe was followed by a 4-byte integer.\n      word0 = this.readInt32();\n      word1 = this.readInt32();\n      if (word1 === 0) {\n        return word0; // don't convert to float if possible\n      }\n      if (word1 < 2097152) {\n        // max exact float point int, 2^52 / 2^32\n        return word1 * 0x100000000 + word0;\n      }\n      res = new Long(word0, word1, !signed); // Long need unsigned\n      const resNumber = res.toNumber();\n      const resString = res.toString();\n      res = resNumber.toString() === resString ? resNumber : resString;\n      return bigNumberStrings ? resString : res;\n    }\n    // eslint-disable-next-line no-console\n    console.trace();\n    throw new Error(`Should not reach here: ${tag}`);\n  }\n\n  readFloat() {\n    const res = this.buffer.readFloatLE(this.offset);\n    this.offset += 4;\n    return res;\n  }\n\n  readDouble() {\n    const res = this.buffer.readDoubleLE(this.offset);\n    this.offset += 8;\n    return res;\n  }\n\n  readBuffer(len) {\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return this.buffer.slice(this.offset - len, this.offset);\n  }\n\n  // DATE, DATETIME and TIMESTAMP\n  readDateTime(timezone) {\n    if (!timezone || timezone === 'Z' || timezone === 'local') {\n      const length = this.readInt8();\n      if (length === 0xfb) {\n        return null;\n      }\n      let y = 0;\n      let m = 0;\n      let d = 0;\n      let H = 0;\n      let M = 0;\n      let S = 0;\n      let ms = 0;\n      if (length > 3) {\n        y = this.readInt16();\n        m = this.readInt8();\n        d = this.readInt8();\n      }\n      if (length > 6) {\n        H = this.readInt8();\n        M = this.readInt8();\n        S = this.readInt8();\n      }\n      if (length > 10) {\n        ms = this.readInt32() / 1000;\n      }\n      // NO_ZERO_DATE mode and NO_ZERO_IN_DATE mode are part of the strict\n      // default SQL mode used by MySQL 8.0. This means that non-standard\n      // dates like '0000-00-00' become NULL. For older versions and other\n      // possible MySQL flavours we still need to account for the\n      // non-standard behaviour.\n      if (y + m + d + H + M + S + ms === 0) {\n        return INVALID_DATE;\n      }\n      if (timezone === 'Z') {\n        return new Date(Date.UTC(y, m - 1, d, H, M, S, ms));\n      }\n      return new Date(y, m - 1, d, H, M, S, ms);\n    }\n    let str = this.readDateTimeString(6, 'T');\n    if (str.length === 10) {\n      str += 'T00:00:00';\n    }\n    return new Date(str + timezone);\n  }\n\n  readDateTimeString(decimals, timeSep) {\n    const length = this.readInt8();\n    let y = 0;\n    let m = 0;\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    let str;\n    if (length > 3) {\n      y = this.readInt16();\n      m = this.readInt8();\n      d = this.readInt8();\n      str = [leftPad(4, y), leftPad(2, m), leftPad(2, d)].join('-');\n    }\n    if (length > 6) {\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n      str += `${timeSep || ' '}${[\n        leftPad(2, H),\n        leftPad(2, M),\n        leftPad(2, S)\n      ].join(':')}`;\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n      str += '.';\n      if (decimals) {\n        ms = leftPad(6, ms);\n        if (ms.length > decimals) {\n          ms = ms.substring(0, decimals); // rounding is done at the MySQL side, only 0 are here\n        }\n      }\n      str += ms;\n    }\n    return str;\n  }\n\n  // TIME - value as a string, Can be negative\n  readTimeString(convertTtoMs) {\n    const length = this.readInt8();\n    if (length === 0) {\n      return '00:00:00';\n    }\n    const sign = this.readInt8() ? -1 : 1; // 'isNegative' flag byte\n    let d = 0;\n    let H = 0;\n    let M = 0;\n    let S = 0;\n    let ms = 0;\n    if (length > 6) {\n      d = this.readInt32();\n      H = this.readInt8();\n      M = this.readInt8();\n      S = this.readInt8();\n    }\n    if (length > 10) {\n      ms = this.readInt32();\n    }\n    if (convertTtoMs) {\n      H += d * 24;\n      M += H * 60;\n      S += M * 60;\n      ms += S * 1000;\n      ms *= sign;\n      return ms;\n    }\n    // Format follows mySQL TIME format ([-][h]hh:mm:ss[.u[u[u[u[u[u]]]]]])\n    // For positive times below 24 hours, this makes it equal to ISO 8601 times\n    return (\n      (sign === -1 ? '-' : '') +\n      [leftPad(2, d * 24 + H), leftPad(2, M), leftPad(2, S)].join(':') +\n      (ms ? `.${ms}`.replace(/0+$/, '') : '')\n    );\n  }\n\n  readLengthCodedString(encoding) {\n    const len = this.readLengthCodedNumber();\n    // TODO: check manually first byte here to avoid polymorphic return type?\n    if (len === null) {\n      return null;\n    }\n    this.offset += len;\n    // TODO: Use characterSetCode to get proper encoding\n    // https://github.com/sidorares/node-mysql2/pull/374\n    return StringParser.decode(\n      this.buffer,\n      encoding,\n      this.offset - len,\n      this.offset\n    );\n  }\n\n  readLengthCodedBuffer() {\n    const len = this.readLengthCodedNumber();\n    if (len === null) {\n      return null;\n    }\n    return this.readBuffer(len);\n  }\n\n  readNullTerminatedString(encoding) {\n    const start = this.offset;\n    let end = this.offset;\n    while (this.buffer[end]) {\n      end = end + 1; // TODO: handle OOB check\n    }\n    this.offset = end + 1;\n    return StringParser.decode(this.buffer, encoding, start, end);\n  }\n\n  // TODO reuse?\n  readString(len, encoding) {\n    if (typeof len === 'string' && typeof encoding === 'undefined') {\n      encoding = len;\n      len = undefined;\n    }\n    if (typeof len === 'undefined') {\n      len = this.end - this.offset;\n    }\n    this.offset += len;\n    return StringParser.decode(\n      this.buffer,\n      encoding,\n      this.offset - len, \n      this.offset\n    );\n  }\n\n  parseInt(len, supportBigNumbers) {\n    if (len === null) {\n      return null;\n    }\n    if (len >= 14 && !supportBigNumbers) {\n      const s = this.buffer.toString('ascii', this.offset, this.offset + len);\n      this.offset += len;\n      return Number(s);\n    }\n    let result = 0;\n    const start = this.offset;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    // max precise int is 9007199254740992\n    let str;\n    const numDigits = end - this.offset;\n    if (supportBigNumbers) {\n      if (numDigits >= 15) {\n        str = this.readString(end - this.offset, 'binary');\n        result = parseInt(str, 10);\n        if (result.toString() === str) {\n          return sign * result;\n        }\n        return sign === -1 ? `-${str}` : str;\n      }\n      if (numDigits > 16) {\n        str = this.readString(end - this.offset);\n        return sign === -1 ? `-${str}` : str;\n      }\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    const num = result * sign;\n    if (!supportBigNumbers) {\n      return num;\n    }\n    str = this.buffer.toString('ascii', start, end);\n    if (num.toString() === str) {\n      return num;\n    }\n    return str;\n  }\n\n  // note that if value of inputNumberAsString is bigger than MAX_SAFE_INTEGER\n  // ( or smaller than MIN_SAFE_INTEGER ) the parseIntNoBigCheck result might be\n  // different from what you would get from Number(inputNumberAsString)\n  // String(parseIntNoBigCheck) <> String(Number(inputNumberAsString)) <> inputNumberAsString\n  parseIntNoBigCheck(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let sign = 1;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      sign = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      result *= 10;\n      result += this.buffer[this.offset] - 48;\n      this.offset++;\n    }\n    return result * sign;\n  }\n\n  // copy-paste from https://github.com/mysqljs/mysql/blob/master/lib/protocol/Parser.js\n  parseGeometryValue() {\n    const buffer = this.readLengthCodedBuffer();\n    let offset = 4;\n    if (buffer === null || !buffer.length) {\n      return null;\n    }\n    function parseGeometry() {\n      let x, y, i, j, numPoints, line;\n      let result = null;\n      const byteOrder = buffer.readUInt8(offset);\n      offset += 1;\n      const wkbType = byteOrder\n        ? buffer.readUInt32LE(offset)\n        : buffer.readUInt32BE(offset);\n      offset += 4;\n      switch (wkbType) {\n        case 1: // WKBPoint\n          x = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          y = byteOrder\n            ? buffer.readDoubleLE(offset)\n            : buffer.readDoubleBE(offset);\n          offset += 8;\n          result = { x: x, y: y };\n          break;\n        case 2: // WKBLineString\n          numPoints = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numPoints; i > 0; i--) {\n            x = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            y = byteOrder\n              ? buffer.readDoubleLE(offset)\n              : buffer.readDoubleBE(offset);\n            offset += 8;\n            result.push({ x: x, y: y });\n          }\n          break;\n        case 3: // WKBPolygon\n          // eslint-disable-next-line no-case-declarations\n          const numRings = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = numRings; i > 0; i--) {\n            numPoints = byteOrder\n              ? buffer.readUInt32LE(offset)\n              : buffer.readUInt32BE(offset);\n            offset += 4;\n            line = [];\n            for (j = numPoints; j > 0; j--) {\n              x = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              y = byteOrder\n                ? buffer.readDoubleLE(offset)\n                : buffer.readDoubleBE(offset);\n              offset += 8;\n              line.push({ x: x, y: y });\n            }\n            result.push(line);\n          }\n          break;\n        case 4: // WKBMultiPoint\n        case 5: // WKBMultiLineString\n        case 6: // WKBMultiPolygon\n        case 7: // WKBGeometryCollection\n          // eslint-disable-next-line no-case-declarations\n          const num = byteOrder\n            ? buffer.readUInt32LE(offset)\n            : buffer.readUInt32BE(offset);\n          offset += 4;\n          result = [];\n          for (i = num; i > 0; i--) {\n            result.push(parseGeometry());\n          }\n          break;\n      }\n      return result;\n    }\n    return parseGeometry();\n  }\n\n  parseDate(timezone) {\n    const strLen = this.readLengthCodedNumber();\n    if (strLen === null) {\n      return null;\n    }\n    if (strLen !== 10) {\n      // we expect only YYYY-MM-DD here.\n      // if for some reason it's not the case return invalid date\n      return new Date(NaN);\n    }\n    const y = this.parseInt(4);\n    this.offset++; // -\n    const m = this.parseInt(2);\n    this.offset++; // -\n    const d = this.parseInt(2);\n    if (!timezone || timezone === 'local') {\n      return new Date(y, m - 1, d);\n    }\n    if (timezone === 'Z') {\n      return new Date(Date.UTC(y, m - 1, d));\n    }\n    return new Date(\n      `${leftPad(4, y)}-${leftPad(2, m)}-${leftPad(2, d)}T00:00:00${timezone}`\n    );\n  }\n\n  parseDateTime(timezone) {\n    const str = this.readLengthCodedString('binary');\n    if (str === null) {\n      return null;\n    }\n    if (!timezone || timezone === 'local') {\n      return new Date(str);\n    }\n    return new Date(`${str}${timezone}`);\n  }\n\n  parseFloat(len) {\n    if (len === null) {\n      return null;\n    }\n    let result = 0;\n    const end = this.offset + len;\n    let factor = 1;\n    let pastDot = false;\n    let charCode = 0;\n    if (len === 0) {\n      return 0; // TODO: assert? exception?\n    }\n    if (this.buffer[this.offset] === minus) {\n      this.offset++;\n      factor = -1;\n    }\n    if (this.buffer[this.offset] === plus) {\n      this.offset++; // just ignore\n    }\n    while (this.offset < end) {\n      charCode = this.buffer[this.offset];\n      if (charCode === dot) {\n        pastDot = true;\n        this.offset++;\n      } else if (charCode === exponent || charCode === exponentCapital) {\n        this.offset++;\n        const exponentValue = this.parseInt(end - this.offset);\n        return (result / factor) * Math.pow(10, exponentValue);\n      } else {\n        result *= 10;\n        result += this.buffer[this.offset] - 48;\n        this.offset++;\n        if (pastDot) {\n          factor = factor * 10;\n        }\n      }\n    }\n    return result / factor;\n  }\n\n  parseLengthCodedIntNoBigCheck() {\n    return this.parseIntNoBigCheck(this.readLengthCodedNumber());\n  }\n\n  parseLengthCodedInt(supportBigNumbers) {\n    return this.parseInt(this.readLengthCodedNumber(), supportBigNumbers);\n  }\n\n  parseLengthCodedIntString() {\n    return this.readLengthCodedString('binary');\n  }\n\n  parseLengthCodedFloat() {\n    return this.parseFloat(this.readLengthCodedNumber());\n  }\n\n  peekByte() {\n    return this.buffer[this.offset];\n  }\n\n  // OxFE is often used as \"Alt\" flag - not ok, not error.\n  // For example, it's first byte of AuthSwitchRequest\n  isAlt() {\n    return this.peekByte() === 0xfe;\n  }\n\n  isError() {\n    return this.peekByte() === 0xff;\n  }\n\n  asError(encoding) {\n    this.reset();\n    this.readInt8(); // fieldCount\n    const errorCode = this.readInt16();\n    let sqlState = '';\n    if (this.buffer[this.offset] === 0x23) {\n      this.skip(1);\n      sqlState = this.readBuffer(5).toString();\n    }\n    const message = this.readString(undefined, encoding);\n    const err = new Error(message);\n    err.code = ErrorCodeToName[errorCode];\n    err.errno = errorCode;\n    err.sqlState = sqlState;\n    err.sqlMessage = message;\n    return err;\n  }\n\n  writeInt32(n) {\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n  }\n\n  writeInt24(n) {\n    this.writeInt8(n & 0xff);\n    this.writeInt16(n >> 8);\n  }\n\n  writeInt16(n) {\n    this.buffer.writeUInt16LE(n, this.offset);\n    this.offset += 2;\n  }\n\n  writeInt8(n) {\n    this.buffer.writeUInt8(n, this.offset);\n    this.offset++;\n  }\n\n  writeDouble(n) {\n    this.buffer.writeDoubleLE(n, this.offset);\n    this.offset += 8;\n  }\n\n  writeBuffer(b) {\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeNull() {\n    this.buffer[this.offset] = 0xfb;\n    this.offset++;\n  }\n\n  // TODO: refactor following three?\n  writeNullTerminatedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n    this.writeInt8(0);\n  }\n\n  writeString(s, encoding) {\n    if (s === null) {\n      this.writeInt8(0xfb);\n      return;\n    }\n    if (s.length === 0) {\n      return;\n    }\n    // const bytes = Buffer.byteLength(s, 'utf8');\n    // this.buffer.write(s, this.offset, bytes, 'utf8');\n    // this.offset += bytes;\n    const buf = StringParser.encode(s, encoding);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedString(s, encoding) {\n    const buf = StringParser.encode(s, encoding);\n    this.writeLengthCodedNumber(buf.length);\n    this.buffer.length && buf.copy(this.buffer, this.offset);\n    this.offset += buf.length;\n  }\n\n  writeLengthCodedBuffer(b) {\n    this.writeLengthCodedNumber(b.length);\n    b.copy(this.buffer, this.offset);\n    this.offset += b.length;\n  }\n\n  writeLengthCodedNumber(n) {\n    if (n < 0xfb) {\n      return this.writeInt8(n);\n    }\n    if (n < 0xffff) {\n      this.writeInt8(0xfc);\n      return this.writeInt16(n);\n    }\n    if (n < 0xffffff) {\n      this.writeInt8(0xfd);\n      return this.writeInt24(n);\n    }\n    if (n === null) {\n      return this.writeInt8(0xfb);\n    }\n    // TODO: check that n is out of int precision\n    this.writeInt8(0xfe);\n    this.buffer.writeUInt32LE(n, this.offset);\n    this.offset += 4;\n    this.buffer.writeUInt32LE(n >> 32, this.offset);\n    this.offset += 4;\n    return this.offset;\n  }\n\n  writeDate(d, timezone) {\n    this.buffer.writeUInt8(11, this.offset);\n    if (!timezone || timezone === 'local') {\n      this.buffer.writeUInt16LE(d.getFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getMilliseconds() * 1000, this.offset + 8);\n    } else {\n      if (timezone !== 'Z') {\n        const offset =\n          (timezone[0] === '-' ? -1 : 1) *\n          (parseInt(timezone.substring(1, 3), 10) * 60 +\n            parseInt(timezone.substring(4), 10));\n        if (offset !== 0) {\n          d = new Date(d.getTime() + 60000 * offset);\n        }\n      }\n      this.buffer.writeUInt16LE(d.getUTCFullYear(), this.offset + 1);\n      this.buffer.writeUInt8(d.getUTCMonth() + 1, this.offset + 3);\n      this.buffer.writeUInt8(d.getUTCDate(), this.offset + 4);\n      this.buffer.writeUInt8(d.getUTCHours(), this.offset + 5);\n      this.buffer.writeUInt8(d.getUTCMinutes(), this.offset + 6);\n      this.buffer.writeUInt8(d.getUTCSeconds(), this.offset + 7);\n      this.buffer.writeUInt32LE(d.getUTCMilliseconds() * 1000, this.offset + 8);\n    }\n    this.offset += 12;\n  }\n\n  writeHeader(sequenceId) {\n    const offset = this.offset;\n    this.offset = 0;\n    this.writeInt24(this.buffer.length - 4);\n    this.writeInt8(sequenceId);\n    this.offset = offset;\n  }\n\n  clone() {\n    return new Packet(this.sequenceId, this.buffer, this.start, this.end);\n  }\n\n  type() {\n    if (this.isEOF()) {\n      return 'EOF';\n    }\n    if (this.isError()) {\n      return 'Error';\n    }\n    if (this.buffer[this.offset] === 0) {\n      return 'maybeOK'; // could be other packet types as well\n    }\n    return '';\n  }\n\n  static lengthCodedNumberLength(n) {\n    if (n < 0xfb) {\n      return 1;\n    }\n    if (n < 0xffff) {\n      return 3;\n    }\n    if (n < 0xffffff) {\n      return 5;\n    }\n    return 9;\n  }\n\n  static lengthCodedStringLength(str, encoding) {\n    const buf = StringParser.encode(str, encoding);\n    const slen = buf.length;\n    return Packet.lengthCodedNumberLength(slen) + slen;\n  }\n\n  static MockBuffer() {\n    const noop = function () {};\n    const res = Buffer.alloc(0);\n    for (const op in NativeBuffer.prototype) {\n      if (typeof res[op] === 'function') {\n        res[op] = noop;\n      }\n    }\n    return res;\n  }\n}\n\nmodule.exports = Packet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}