{"ast":null,"code":"'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers = options.supportBigNumbers || config.supportBigNumbers;\n  const bigNumberStrings = options.bigNumberStrings || config.bigNumberStrings;\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n    case Types.LONG:\n    case Types.INT24:\n      // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n    case Types.YEAR:\n      return 'packet.readInt16()';\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n    case Types.NULL:\n      return 'null;';\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return `packet.readDateTimeString(${field.decimals});`;\n      }\n      return `packet.readDateTime('${timezone}');`;\n    case Types.TIME:\n      return 'packet.readTimeString()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n      return 'packet.readLengthCodedString(\"ascii\");';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned ? 'packet.readInt64JSNumber();' : 'packet.readSInt64JSNumber();';\n      }\n      if (bigNumberStrings) {\n        return unsigned ? 'packet.readInt64String();' : 'packet.readSInt64String();';\n      }\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;\n  }\n}\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  let i = 0;\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n\n  /* eslint-disable no-trailing-spaces */\n  /* eslint-disable no-spaced-func */\n  /* eslint-disable no-unexpected-multiline */\n\n  parserFn('(function(){');\n  parserFn('return class BinaryRow {');\n  parserFn('constructor() {');\n  parserFn('}');\n  parserFn('next(packet, fields, options) {');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn(\"const result = {};\");\n  }\n  const resultTables = {};\n  let resultTablesArray = [];\n  if (options.nestTables === true) {\n    for (i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n    resultTablesArray = Object.keys(resultTables);\n    for (i = 0; i < resultTablesArray.length; i++) {\n      parserFn(`result[${helpers.srcEscape(resultTablesArray[i])}] = {};`);\n    }\n  }\n  parserFn('packet.readInt8();'); // status byte\n  for (i = 0; i < nullBitmapLength; ++i) {\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\n  }\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n  for (i = 0; i < fields.length; i++) {\n    fieldName = helpers.srcEscape(fields[i].name);\n    parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n    if (typeof options.nestTables === 'string') {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = `result[${helpers.srcEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${helpers.srcEscape(fields[i].name)}]`;\n    }\n\n    // TODO: this used to be an optimisation ( if column marked as NOT_NULL don't include code to check null\n    // bitmap at all, but it seems that we can't rely on this flag, see #178\n    // TODO: benchmark performance difference\n    //\n    // if (fields[i].flags & FieldFlags.NOT_NULL) { // don't need to check null bitmap if field can't be null.\n    //  result.push(lvalue + ' = ' + readCodeFor(fields[i], config));\n    // } else if (fields[i].columnType == Types.NULL) {\n    //  result.push(lvalue + ' = null;');\n    // } else {\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit})`);\n    parserFn(`${lvalue} = null;`);\n    parserFn('else');\n    parserFn(`${lvalue} = ${readCodeFor(fields[i], config, options, i)}`);\n    // }\n    currentFieldNullBit *= 2;\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n\n  /* eslint-enable no-trailing-spaces */\n  /* eslint-enable no-spaced-func */\n  /* eslint-enable no-unexpected-multiline */\n\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled binary protocol row parser', parserFn.toString());\n  }\n  return parserFn.toFunction();\n}\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\nmodule.exports = getBinaryParser;","map":{"version":3,"names":["FieldFlags","require","Charsets","Types","helpers","genFunc","parserCache","typeNames","t","readCodeFor","field","config","options","fieldNum","supportBigNumbers","bigNumberStrings","timezone","dateStrings","unsigned","flags","UNSIGNED","columnType","TINY","SHORT","LONG","INT24","YEAR","FLOAT","DOUBLE","NULL","DATE","DATETIME","TIMESTAMP","NEWDATE","typeMatch","decimals","TIME","DECIMAL","NEWDECIMAL","decimalNumbers","GEOMETRY","JSON","LONGLONG","characterSet","BINARY","compile","fields","parserFn","i","nullBitmapLength","Math","floor","length","rowsAsArray","resultTables","resultTablesArray","nestTables","table","Object","keys","srcEscape","lvalue","currentFieldNullBit","nullByteIndex","fieldName","tableName","name","toString","debug","printDebugWithCode","toFunction","getBinaryParser","getParser","module","exports"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/mysql2/lib/parsers/binary_parser.js"],"sourcesContent":["'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\n\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers =\n    options.supportBigNumbers || config.supportBigNumbers;\n  const bigNumberStrings = options.bigNumberStrings || config.bigNumberStrings;\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n    case Types.LONG:\n    case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n    case Types.YEAR:\n      return 'packet.readInt16()';\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n    case Types.NULL:\n      return 'null;';\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return `packet.readDateTimeString(${field.decimals});`;\n      }\n      return `packet.readDateTime('${timezone}');`;\n    case Types.TIME:\n      return 'packet.readTimeString()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n      return 'packet.readLengthCodedString(\"ascii\");';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned\n          ? 'packet.readInt64JSNumber();'\n          : 'packet.readSInt64JSNumber();';\n      }\n      if (bigNumberStrings) {\n        return unsigned\n          ? 'packet.readInt64String();'\n          : 'packet.readSInt64String();';\n      }\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;\n  }\n}\n\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  let i = 0;\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n\n  /* eslint-disable no-trailing-spaces */\n  /* eslint-disable no-spaced-func */\n  /* eslint-disable no-unexpected-multiline */\n\n  parserFn('(function(){');\n  parserFn('return class BinaryRow {');\n  parserFn('constructor() {');\n  parserFn('}');\n\n  parserFn('next(packet, fields, options) {');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn(\"const result = {};\");\n  }\n\n  const resultTables = {};\n  let resultTablesArray = [];\n\n  if (options.nestTables === true) {\n    for (i = 0; i < fields.length; i++) {\n      resultTables[fields[i].table] = 1;\n    }\n    resultTablesArray = Object.keys(resultTables);\n    for (i = 0; i < resultTablesArray.length; i++) {\n      parserFn(`result[${helpers.srcEscape(resultTablesArray[i])}] = {};`);\n    }\n  }\n\n  parserFn('packet.readInt8();'); // status byte\n  for (i = 0; i < nullBitmapLength; ++i) {\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\n  }\n\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n\n  for (i = 0; i < fields.length; i++) {\n    fieldName = helpers.srcEscape(fields[i].name);\n    parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = `result[${helpers.srcEscape(\n        fields[i].table + options.nestTables + fields[i].name\n      )}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.srcEscape(fields[i].table);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${helpers.srcEscape(fields[i].name)}]`;\n    }\n\n    // TODO: this used to be an optimisation ( if column marked as NOT_NULL don't include code to check null\n    // bitmap at all, but it seems that we can't rely on this flag, see #178\n    // TODO: benchmark performance difference\n    //\n    // if (fields[i].flags & FieldFlags.NOT_NULL) { // don't need to check null bitmap if field can't be null.\n    //  result.push(lvalue + ' = ' + readCodeFor(fields[i], config));\n    // } else if (fields[i].columnType == Types.NULL) {\n    //  result.push(lvalue + ' = null;');\n    // } else {\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit})`);\n    parserFn(`${lvalue} = null;`);\n    parserFn('else');\n    parserFn(`${lvalue} = ${readCodeFor(fields[i], config, options, i)}`);\n    // }\n    currentFieldNullBit *= 2;\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n\n  /* eslint-enable no-trailing-spaces */\n  /* eslint-enable no-spaced-func */\n  /* eslint-enable no-unexpected-multiline */\n\n  if (config.debug) {\n    helpers.printDebugWithCode(\n      'Compiled binary protocol row parser',\n      parserFn.toString()\n    );\n  }\n  return parserFn.toFunction();\n}\n\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\n\nmodule.exports = getBinaryParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}