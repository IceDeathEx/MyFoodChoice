{"ast":null,"code":"// This file was modified by Oracle on June 17, 2021.\n// Handshake errors are now maked as fatal and the corresponding events are\n// emitted in the command instance itself.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n// This file was modified by Oracle on September 21, 2021.\n// Handshake workflow now supports additional authentication factors requested\n// by the server.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst Command = require('./command.js');\nconst Packets = require('../packets/index.js');\nconst ClientConstants = require('../constants/client.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst auth41 = require('../auth_41.js');\nfunction flagNames(flags) {\n  const res = [];\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n  return res;\n}\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n    this.authenticationFactor = 0;\n  }\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(this.clientFlags, connection.config.charsetNumber);\n    connection.writePacket(sslRequest.toPacket());\n  }\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Sending handshake packet: flags:%d=(%s)', this.clientFlags, flagNames(this.clientFlags).join(', '));\n    }\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    // \"password1\" is an alias to the original \"password\" value\n    // to make it easier to integrate multi-factor authentication\n    this.password1 = connection.config.password;\n    // \"password2\" and \"password3\" are the 2nd and 3rd factor authentication\n    // passwords, which can be undefined depending on the authentication\n    // plugin being used\n    this.password2 = connection.config.password2;\n    this.password3 = connection.config.password3;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, authPluginData1, authPluginData2);\n    } else {\n      authToken = auth41.calculateToken(this.password, authPluginData1, authPluginData2);\n    }\n    return authToken;\n  }\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log('Server hello packet: capability flags:%d=(%s)', this.handshake.capabilityFlags, flagNames(this.handshake.capabilityFlags).join(', '));\n    }\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport = this.handshake.capabilityFlags & ClientConstants.SSL;\n    // multi factor authentication is enabled with the\n    // \"MULTI_FACTOR_AUTHENTICATION\" capability and should only be used if it\n    // is supported by the server\n    const multiFactorAuthentication = this.handshake.capabilityFlags & ClientConstants.MULTI_FACTOR_AUTHENTICATION;\n    this.clientFlags = this.clientFlags | multiFactorAuthentication;\n    // use compression only if requested by client and supported by server\n    connection.config.compress = connection.config.compress && this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      }\n      // send ssl upgrade request and immediately upgrade connection to secure\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        }\n        // rest of communication is encrypted\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n    if (multiFactorAuthentication) {\n      // if the server supports multi-factor authentication, we enable it in\n      // the client\n      this.authenticationFactor = 1;\n    }\n    return ClientHandshake.prototype.handshakeResult;\n  }\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n    // packet can be OK_Packet, ERR_Packet, AuthSwitchRequest, AuthNextFactor\n    // or AuthMoreData\n    if (marker === 0xfe || marker === 1 || marker === 0x02) {\n      const authSwitch = require('./auth_switch');\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          // if authenticationFactor === 0, it means the server does not support\n          // the multi-factor authentication capability\n          if (this.authenticationFactor !== 0) {\n            // if we are past the first authentication factor, we should use the\n            // corresponding password (if there is one)\n            connection.config.password = this[`password${this.authenticationFactor}`];\n            // update the current authentication factor\n            this.authenticationFactor += 1;\n          }\n          // if marker === 0x02, it means it is an AuthNextFactor packet,\n          // which is similar in structure to an AuthSwitchRequest packet,\n          // so, we can use it directly\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        // Authentication errors are fatal\n        err.code = 'AUTH_SWITCH_PLUGIN_ERROR';\n        err.fatal = true;\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          this.emit('error', err);\n        }\n        return null;\n      }\n    }\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase');\n      // Unknown handshake errors are fatal\n      err.code = 'HANDSHAKE_UNKNOWN_ERROR';\n      err.fatal = true;\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        this.emit('error', err);\n      }\n      return null;\n    }\n    // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n    if (!connection.authorized) {\n      connection.authorized = true;\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js').enableCompression;\n        enableCompression(connection);\n      }\n    }\n    if (this.onResult) {\n      this.onResult(null);\n    }\n    return null;\n  }\n}\nmodule.exports = ClientHandshake;","map":{"version":3,"names":["Command","require","Packets","ClientConstants","CharsetToEncoding","auth41","flagNames","flags","res","c","push","replace","toLowerCase","ClientHandshake","constructor","clientFlags","handshake","authenticationFactor","start","prototype","handshakeInit","sendSSLRequest","connection","sslRequest","SSLRequest","config","charsetNumber","writePacket","toPacket","sendCredentials","debug","console","log","join","user","password","password1","password2","password3","passwordSha1","database","autPluginName","handshakeResponse","HandshakeResponse","authPluginData1","authPluginData2","compress","connectAttributes","calculateNativePasswordAuthToken","authPluginData","slice","authToken","calculateTokenFromPasswordSha","calculateToken","helloPacket","on","e","_fatalError","_protocolError","Handshake","fromPacket","capabilityFlags","serverCapabilityFlags","serverEncoding","characterSet","connectionId","serverSSLSupport","SSL","multiFactorAuthentication","MULTI_FACTOR_AUTHENTICATION","COMPRESS","ssl","err","Error","code","fatal","emit","startTLS","handshakeResult","packet","marker","peekByte","authSwitch","authSwitchRequestMoreData","authSwitchRequest","onResult","authorized","enableCompression","module","exports"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/mysql2/lib/commands/client_handshake.js"],"sourcesContent":["// This file was modified by Oracle on June 17, 2021.\n// Handshake errors are now maked as fatal and the corresponding events are\n// emitted in the command instance itself.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n// This file was modified by Oracle on September 21, 2021.\n// Handshake workflow now supports additional authentication factors requested\n// by the server.\n// Modifications copyright (c) 2021, Oracle and/or its affiliates.\n\n'use strict';\n\nconst Command = require('./command.js');\nconst Packets = require('../packets/index.js');\nconst ClientConstants = require('../constants/client.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst auth41 = require('../auth_41.js');\n\nfunction flagNames(flags) {\n  const res = [];\n  for (const c in ClientConstants) {\n    if (flags & ClientConstants[c]) {\n      res.push(c.replace(/_/g, ' ').toLowerCase());\n    }\n  }\n  return res;\n}\n\nclass ClientHandshake extends Command {\n  constructor(clientFlags) {\n    super();\n    this.handshake = null;\n    this.clientFlags = clientFlags;\n    this.authenticationFactor = 0;\n  }\n\n  start() {\n    return ClientHandshake.prototype.handshakeInit;\n  }\n\n  sendSSLRequest(connection) {\n    const sslRequest = new Packets.SSLRequest(\n      this.clientFlags,\n      connection.config.charsetNumber\n    );\n    connection.writePacket(sslRequest.toPacket());\n  }\n\n  sendCredentials(connection) {\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        'Sending handshake packet: flags:%d=(%s)',\n        this.clientFlags,\n        flagNames(this.clientFlags).join(', ')\n      );\n    }\n    this.user = connection.config.user;\n    this.password = connection.config.password;\n    // \"password1\" is an alias to the original \"password\" value\n    // to make it easier to integrate multi-factor authentication\n    this.password1 = connection.config.password;\n    // \"password2\" and \"password3\" are the 2nd and 3rd factor authentication\n    // passwords, which can be undefined depending on the authentication\n    // plugin being used\n    this.password2 = connection.config.password2;\n    this.password3 = connection.config.password3;\n    this.passwordSha1 = connection.config.passwordSha1;\n    this.database = connection.config.database;\n    this.autPluginName = this.handshake.autPluginName;\n    const handshakeResponse = new Packets.HandshakeResponse({\n      flags: this.clientFlags,\n      user: this.user,\n      database: this.database,\n      password: this.password,\n      passwordSha1: this.passwordSha1,\n      charsetNumber: connection.config.charsetNumber,\n      authPluginData1: this.handshake.authPluginData1,\n      authPluginData2: this.handshake.authPluginData2,\n      compress: connection.config.compress,\n      connectAttributes: connection.config.connectAttributes\n    });\n    connection.writePacket(handshakeResponse.toPacket());\n  }\n\n  calculateNativePasswordAuthToken(authPluginData) {\n    // TODO: dont split into authPluginData1 and authPluginData2, instead join when 1 & 2 received\n    const authPluginData1 = authPluginData.slice(0, 8);\n    const authPluginData2 = authPluginData.slice(8, 20);\n    let authToken;\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(\n        this.passwordSha1,\n        authPluginData1,\n        authPluginData2\n      );\n    } else {\n      authToken = auth41.calculateToken(\n        this.password,\n        authPluginData1,\n        authPluginData2\n      );\n    }\n    return authToken;\n  }\n\n  handshakeInit(helloPacket, connection) {\n    this.on('error', e => {\n      connection._fatalError = e;\n      connection._protocolError = e;\n    });\n    this.handshake = Packets.Handshake.fromPacket(helloPacket);\n    if (connection.config.debug) {\n      // eslint-disable-next-line\n      console.log(\n        'Server hello packet: capability flags:%d=(%s)',\n        this.handshake.capabilityFlags,\n        flagNames(this.handshake.capabilityFlags).join(', ')\n      );\n    }\n    connection.serverCapabilityFlags = this.handshake.capabilityFlags;\n    connection.serverEncoding = CharsetToEncoding[this.handshake.characterSet];\n    connection.connectionId = this.handshake.connectionId;\n    const serverSSLSupport =\n      this.handshake.capabilityFlags & ClientConstants.SSL;\n    // multi factor authentication is enabled with the\n    // \"MULTI_FACTOR_AUTHENTICATION\" capability and should only be used if it\n    // is supported by the server\n    const multiFactorAuthentication =\n      this.handshake.capabilityFlags & ClientConstants.MULTI_FACTOR_AUTHENTICATION;\n    this.clientFlags = this.clientFlags | multiFactorAuthentication;\n    // use compression only if requested by client and supported by server\n    connection.config.compress =\n      connection.config.compress &&\n      this.handshake.capabilityFlags & ClientConstants.COMPRESS;\n    this.clientFlags = this.clientFlags | connection.config.compress;\n    if (connection.config.ssl) {\n      // client requires SSL but server does not support it\n      if (!serverSSLSupport) {\n        const err = new Error('Server does not support secure connnection');\n        err.code = 'HANDSHAKE_NO_SSL_SUPPORT';\n        err.fatal = true;\n        this.emit('error', err);\n        return false;\n      }\n      // send ssl upgrade request and immediately upgrade connection to secure\n      this.clientFlags |= ClientConstants.SSL;\n      this.sendSSLRequest(connection);\n      connection.startTLS(err => {\n        // after connection is secure\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          this.emit('error', err);\n          return;\n        }\n        // rest of communication is encrypted\n        this.sendCredentials(connection);\n      });\n    } else {\n      this.sendCredentials(connection);\n    }\n    if (multiFactorAuthentication) {\n      // if the server supports multi-factor authentication, we enable it in\n      // the client\n      this.authenticationFactor = 1;\n    }\n    return ClientHandshake.prototype.handshakeResult;\n  }\n\n  handshakeResult(packet, connection) {\n    const marker = packet.peekByte();\n    // packet can be OK_Packet, ERR_Packet, AuthSwitchRequest, AuthNextFactor\n    // or AuthMoreData\n    if (marker === 0xfe || marker === 1 || marker === 0x02) {\n      const authSwitch = require('./auth_switch');\n      try {\n        if (marker === 1) {\n          authSwitch.authSwitchRequestMoreData(packet, connection, this);\n        } else {\n          // if authenticationFactor === 0, it means the server does not support\n          // the multi-factor authentication capability\n          if (this.authenticationFactor !== 0) {\n            // if we are past the first authentication factor, we should use the\n            // corresponding password (if there is one)\n            connection.config.password = this[`password${this.authenticationFactor}`];\n            // update the current authentication factor\n            this.authenticationFactor += 1;\n          }\n          // if marker === 0x02, it means it is an AuthNextFactor packet,\n          // which is similar in structure to an AuthSwitchRequest packet,\n          // so, we can use it directly\n          authSwitch.authSwitchRequest(packet, connection, this);\n        }\n        return ClientHandshake.prototype.handshakeResult;\n      } catch (err) {\n        // Authentication errors are fatal\n        err.code = 'AUTH_SWITCH_PLUGIN_ERROR';\n        err.fatal = true;\n\n        if (this.onResult) {\n          this.onResult(err);\n        } else {\n          this.emit('error', err);\n        }\n        return null;\n      }\n    }\n    if (marker !== 0) {\n      const err = new Error('Unexpected packet during handshake phase');\n      // Unknown handshake errors are fatal\n      err.code = 'HANDSHAKE_UNKNOWN_ERROR';\n      err.fatal = true;\n\n      if (this.onResult) {\n        this.onResult(err);\n      } else {\n        this.emit('error', err);\n      }\n      return null;\n    }\n    // this should be called from ClientHandshake command only\n    // and skipped when called from ChangeUser command\n    if (!connection.authorized) {\n      connection.authorized = true;\n      if (connection.config.compress) {\n        const enableCompression = require('../compressed_protocol.js')\n          .enableCompression;\n        enableCompression(connection);\n      }\n    }\n    if (this.onResult) {\n      this.onResult(null);\n    }\n    return null;\n  }\n}\nmodule.exports = ClientHandshake;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}