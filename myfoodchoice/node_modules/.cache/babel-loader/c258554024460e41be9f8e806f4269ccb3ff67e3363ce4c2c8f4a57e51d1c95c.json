{"ast":null,"code":"'use strict';\n\nconst CursorType = require('../constants/cursor');\nconst CommandCodes = require('../constants/commands');\nconst Types = require('../constants/types');\nconst Packet = require('../packets/packet');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nfunction isJSON(value) {\n  return Array.isArray(value) || value.constructor === Object || typeof value.toJSON === 'function' && !Buffer.isBuffer(value);\n}\n\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n  let writer = function (value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n          writer = function (value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n        break;\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n  return {\n    value,\n    type,\n    length,\n    writer\n  };\n}\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n  static fromPacket(packet, encoding) {\n    const stmtId = packet.readInt32();\n    const flags = packet.readInt8();\n    const iterationCount = packet.readInt32();\n    let i = packet.offset;\n    while (i < packet.end - 1) {\n      if ((packet.buffer[i + 1] === Types.VAR_STRING || packet.buffer[i + 1] === Types.NULL || packet.buffer[i + 1] === Types.DOUBLE || packet.buffer[i + 1] === Types.TINY || packet.buffer[i + 1] === Types.DATETIME || packet.buffer[i + 1] === Types.JSON) && packet.buffer[i] === 1 && packet.buffer[i + 2] === 0) {\n        break;\n      } else {\n        packet.readInt8();\n      }\n      i++;\n    }\n    const types = [];\n    for (let i = packet.offset + 1; i < packet.end - 1; i++) {\n      if ((packet.buffer[i] === Types.VAR_STRING || packet.buffer[i] === Types.NULL || packet.buffer[i] === Types.DOUBLE || packet.buffer[i] === Types.TINY || packet.buffer[i] === Types.DATETIME || packet.buffer[i] === Types.JSON) && packet.buffer[i + 1] === 0) {\n        types.push(packet.buffer[i]);\n        packet.skip(2);\n      }\n    }\n    packet.skip(1);\n    const values = [];\n    for (let i = 0; i < types.length; i++) {\n      if (types[i] === Types.VAR_STRING) {\n        values.push(packet.readLengthCodedString(encoding));\n      } else if (types[i] === Types.DOUBLE) {\n        values.push(packet.readDouble());\n      } else if (types[i] === Types.TINY) {\n        values.push(packet.readInt8());\n      } else if (types[i] === Types.DATETIME) {\n        values.push(packet.readDateTime());\n      } else if (types[i] === Types.JSON) {\n        values.push(JSON.parse(packet.readLengthCodedString(encoding)));\n      }\n      if (types[i] === Types.NULL) {\n        values.push(null);\n      }\n    }\n    return {\n      stmtId,\n      flags,\n      iterationCount,\n      values\n    };\n  }\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n      parameters = this.parameters.map(value => toParameter(value, this.encoding, this.timezone));\n      length += parameters.reduce((accumulator, parameter) => accumulator + parameter.length, 0);\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n    packet.writeInt32(1); // iteration-count, always 1\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n        bitValue *= 2;\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      }\n      // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n        packet.writeInt8(0); // parameter flag\n      });\n      // Write parameter values\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n    return packet;\n  }\n}\nmodule.exports = Execute;","map":{"version":3,"names":["CursorType","require","CommandCodes","Types","Packet","CharsetToEncoding","isJSON","value","Array","isArray","constructor","Object","toJSON","Buffer","isBuffer","toParameter","encoding","timezone","type","VAR_STRING","length","writer","prototype","writeLengthCodedString","call","TypeError","DOUBLE","writeDouble","TINY","writeInt8","toString","DATETIME","writeDate","JSON","stringify","lengthCodedNumberLength","writeLengthCodedBuffer","NULL","lengthCodedStringLength","Execute","id","parameters","charsetNumber","fromPacket","packet","stmtId","readInt32","flags","readInt8","iterationCount","i","offset","end","buffer","types","push","skip","values","readLengthCodedString","readDouble","readDateTime","parse","toPacket","Math","floor","map","reduce","accumulator","parameter","allocUnsafe","STMT_EXECUTE","writeInt32","NO_CURSOR","bitmap","bitValue","forEach","module","exports"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/mysql2/lib/packets/execute.js"],"sourcesContent":["'use strict';\n\nconst CursorType = require('../constants/cursor');\nconst CommandCodes = require('../constants/commands');\nconst Types = require('../constants/types');\nconst Packet = require('../packets/packet');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nfunction isJSON(value) {\n  return (\n    Array.isArray(value) ||\n    value.constructor === Object ||\n    (typeof value.toJSON === 'function' && !Buffer.isBuffer(value))\n  );\n}\n\n/**\n * Converts a value to an object describing type, String/Buffer representation and length\n * @param {*} value\n */\nfunction toParameter(value, encoding, timezone) {\n  let type = Types.VAR_STRING;\n  let length;\n  let writer = function(value) {\n    // eslint-disable-next-line no-invalid-this\n    return Packet.prototype.writeLengthCodedString.call(this, value, encoding);\n  };\n  if (value !== null) {\n    switch (typeof value) {\n      case 'undefined':\n        throw new TypeError('Bind parameters must not contain undefined');\n\n      case 'number':\n        type = Types.DOUBLE;\n        length = 8;\n        writer = Packet.prototype.writeDouble;\n        break;\n\n      case 'boolean':\n        value = value | 0;\n        type = Types.TINY;\n        length = 1;\n        writer = Packet.prototype.writeInt8;\n        break;\n\n      case 'object':\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          type = Types.DATETIME;\n          length = 12;\n          writer = function(value) {\n            // eslint-disable-next-line no-invalid-this\n            return Packet.prototype.writeDate.call(this, value, timezone);\n          };\n        } else if (isJSON(value)) {\n          value = JSON.stringify(value);\n          type = Types.JSON;\n        } else if (Buffer.isBuffer(value)) {\n          length = Packet.lengthCodedNumberLength(value.length) + value.length;\n          writer = Packet.prototype.writeLengthCodedBuffer;\n        }\n        break;\n\n      default:\n        value = value.toString();\n    }\n  } else {\n    value = '';\n    type = Types.NULL;\n  }\n  if (!length) {\n    length = Packet.lengthCodedStringLength(value, encoding);\n  }\n  return { value, type, length, writer };\n}\n\nclass Execute {\n  constructor(id, parameters, charsetNumber, timezone) {\n    this.id = id;\n    this.parameters = parameters;\n    this.encoding = CharsetToEncoding[charsetNumber];\n    this.timezone = timezone;\n  }\n\n  static fromPacket(packet, encoding) {\n    const stmtId = packet.readInt32();\n    const flags = packet.readInt8();\n    const iterationCount = packet.readInt32();\n\n    let i = packet.offset;\n    while (i < packet.end - 1) {\n      if((packet.buffer[i+1] === Types.VAR_STRING \n        || packet.buffer[i+1] === Types.NULL \n        || packet.buffer[i+1] === Types.DOUBLE\n        || packet.buffer[i+1] === Types.TINY\n        || packet.buffer[i+1] === Types.DATETIME\n        || packet.buffer[i+1] === Types.JSON) && packet.buffer[i] === 1 && packet.buffer[i+2] === 0) {\n        break;\n      }\n      else {\n        packet.readInt8()\n      }\n      i++;\n    }\n\n    const types = [];\n\n    for(let i = packet.offset + 1; i < packet.end - 1; i++) {\n      if((packet.buffer[i] === Types.VAR_STRING \n        || packet.buffer[i] === Types.NULL \n        || packet.buffer[i] === Types.DOUBLE\n        || packet.buffer[i] === Types.TINY\n        || packet.buffer[i] === Types.DATETIME\n        || packet.buffer[i] === Types.JSON) && packet.buffer[i + 1] === 0) {\n        types.push(packet.buffer[i]);\n        packet.skip(2);\n      }\n    }\n\n    packet.skip(1);\n\n    const values = [];\n    for(let i = 0; i < types.length; i++) {\n      if(types[i] === Types.VAR_STRING) {\n        values.push(packet.readLengthCodedString(encoding))\n      }\n      else if(types[i] === Types.DOUBLE) {\n        values.push(packet.readDouble())\n      }\n      else if(types[i] === Types.TINY) {\n        values.push(packet.readInt8())\n      }\n      else if(types[i] === Types.DATETIME) {\n        values.push(packet.readDateTime())\n      }\n      else if(types[i] === Types.JSON) {\n        values.push(JSON.parse(packet.readLengthCodedString(encoding)))\n      }\n      if(types[i] === Types.NULL) {\n        values.push(null)\n      }\n    }\n\n    return { stmtId, flags, iterationCount, values };\n  }\n\n  toPacket() {\n    // TODO: don't try to calculate packet length in advance, allocate some big buffer in advance (header + 256 bytes?)\n    // and copy + reallocate if not enough\n    // 0 + 4 - length, seqId\n    // 4 + 1 - COM_EXECUTE\n    // 5 + 4 - stmtId\n    // 9 + 1 - flags\n    // 10 + 4 - iteration-count (always 1)\n    let length = 14;\n    let parameters;\n    if (this.parameters && this.parameters.length > 0) {\n      length += Math.floor((this.parameters.length + 7) / 8);\n      length += 1; // new-params-bound-flag\n      length += 2 * this.parameters.length; // type byte for each parameter if new-params-bound-flag is set\n      parameters = this.parameters.map(value =>\n        toParameter(value, this.encoding, this.timezone)\n      );\n      length += parameters.reduce(\n        (accumulator, parameter) => accumulator + parameter.length,\n        0\n      );\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeInt8(CommandCodes.STMT_EXECUTE);\n    packet.writeInt32(this.id);\n    packet.writeInt8(CursorType.NO_CURSOR); // flags\n    packet.writeInt32(1); // iteration-count, always 1\n    if (parameters) {\n      let bitmap = 0;\n      let bitValue = 1;\n      parameters.forEach(parameter => {\n        if (parameter.type === Types.NULL) {\n          bitmap += bitValue;\n        }\n        bitValue *= 2;\n        if (bitValue === 256) {\n          packet.writeInt8(bitmap);\n          bitmap = 0;\n          bitValue = 1;\n        }\n      });\n      if (bitValue !== 1) {\n        packet.writeInt8(bitmap);\n      }\n      // TODO: explain meaning of the flag\n      // afaik, if set n*2 bytes with type of parameter are sent before parameters\n      // if not, previous execution types are used (TODO prooflink)\n      packet.writeInt8(1); // new-params-bound-flag\n      // Write parameter types\n      parameters.forEach(parameter => {\n        packet.writeInt8(parameter.type); // field type\n        packet.writeInt8(0); // parameter flag\n      });\n      // Write parameter values\n      parameters.forEach(parameter => {\n        if (parameter.type !== Types.NULL) {\n          parameter.writer.call(packet, parameter.value);\n        }\n      });\n    }\n    return packet;\n  }\n}\n\nmodule.exports = Execute;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}