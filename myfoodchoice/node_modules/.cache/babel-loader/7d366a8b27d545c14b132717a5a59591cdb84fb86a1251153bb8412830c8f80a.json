{"ast":null,"code":"'use strict';\n\nconst Packet = require('./packets/packet.js');\nconst MAX_PACKET_LENGTH = 16777215;\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n  return b0 + (b1 << 8) + (b2 << 16);\n}\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    }\n    // array of last payload chunks\n    // only used when current payload is not complete\n    this.buffer = [];\n    // total length of chunks on buffer\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength;\n    // incomplete header state: number of header bytes received\n    this.headerLen = 0;\n    // expected payload length\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket = packetHeaderLength === 7 ? this._flushLargePacket7 : this._flushLargePacket4;\n  }\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n        if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n          this.onPacket(new Packet(sequenceId, chunk, start, start + this.packetHeaderLength + this.length));\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n          this.largePacketParts.push(chunk.slice(start + this.packetHeaderLength, start + this.packetHeaderLength + this.length));\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n      this.length = chunk[start];\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload = this.length - this.bufferLength + this.packetHeaderLength - 3;\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n      if (this.length < MAX_PACKET_LENGTH && this.largePacketParts.length === 0) {\n        this.onPacket(new Packet(sequenceId, payload, 0, this.length + this.packetHeaderLength));\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n        this.largePacketParts.push(payload.slice(this.packetHeaderLength, this.packetHeaderLength + this.length));\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n    return null;\n  }\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    }\n    this.execute = PacketParser.prototype.executeHeader3;\n    return null;\n  }\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n}\nmodule.exports = PacketParser;","map":{"version":3,"names":["Packet","require","MAX_PACKET_LENGTH","readPacketLength","b","off","b0","b1","b2","PacketParser","constructor","onPacket","packetHeaderLength","buffer","bufferLength","headerLen","length","largePacketParts","firstPacketSequenceId","execute","prototype","executeStart","_flushLargePacket","_flushLargePacket7","_flushLargePacket4","numPackets","unshift","Buffer","from","body","concat","packet","chunk","start","end","sequenceId","push","slice","executePayload","executeHeader3","executeHeader2","remainingPayload","payload","allocUnsafe","offset","i","copy","module","exports"],"sources":["C:/Users/runes/FYP/myfoodchoice/node_modules/mysql2/lib/packet_parser.js"],"sourcesContent":["'use strict';\n\nconst Packet = require('./packets/packet.js');\n\nconst MAX_PACKET_LENGTH = 16777215;\n\nfunction readPacketLength(b, off) {\n  const b0 = b[off];\n  const b1 = b[off + 1];\n  const b2 = b[off + 2];\n  if (b1 + b2 === 0) {\n    return b0;\n  }\n  return b0 + (b1 << 8) + (b2 << 16);\n}\n\nclass PacketParser {\n  constructor(onPacket, packetHeaderLength) {\n    // 4 for normal packets, 7 for comprssed protocol packets\n    if (typeof packetHeaderLength === 'undefined') {\n      packetHeaderLength = 4;\n    }\n    // array of last payload chunks\n    // only used when current payload is not complete\n    this.buffer = [];\n    // total length of chunks on buffer\n    this.bufferLength = 0;\n    this.packetHeaderLength = packetHeaderLength;\n    // incomplete header state: number of header bytes received\n    this.headerLen = 0;\n    // expected payload length\n    this.length = 0;\n    this.largePacketParts = [];\n    this.firstPacketSequenceId = 0;\n    this.onPacket = onPacket;\n    this.execute = PacketParser.prototype.executeStart;\n    this._flushLargePacket =\n      packetHeaderLength === 7\n        ? this._flushLargePacket7\n        : this._flushLargePacket4;\n  }\n\n  _flushLargePacket4() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    this.largePacketParts.length = 0;\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  _flushLargePacket7() {\n    const numPackets = this.largePacketParts.length;\n    this.largePacketParts.unshift(Buffer.from([0, 0, 0, 0, 0, 0, 0])); // insert header\n    const body = Buffer.concat(this.largePacketParts);\n    this.largePacketParts.length = 0;\n    const packet = new Packet(this.firstPacketSequenceId, body, 0, body.length);\n    packet.numPackets = numPackets;\n    this.onPacket(packet);\n  }\n\n  executeStart(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    while (end - start >= 3) {\n      this.length = readPacketLength(chunk, start);\n      if (end - start >= this.length + this.packetHeaderLength) {\n        // at least one full packet\n        const sequenceId = chunk[start + 3];\n        if (\n          this.length < MAX_PACKET_LENGTH &&\n          this.largePacketParts.length === 0\n        ) {\n          this.onPacket(\n            new Packet(\n              sequenceId,\n              chunk,\n              start,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n        } else {\n          // first large packet - remember it's id\n          if (this.largePacketParts.length === 0) {\n            this.firstPacketSequenceId = sequenceId;\n          }\n          this.largePacketParts.push(\n            chunk.slice(\n              start + this.packetHeaderLength,\n              start + this.packetHeaderLength + this.length\n            )\n          );\n          if (this.length < MAX_PACKET_LENGTH) {\n            this._flushLargePacket();\n          }\n        }\n        start += this.packetHeaderLength + this.length;\n      } else {\n        // payload is incomplete\n        this.buffer = [chunk.slice(start + 3, end)];\n        this.bufferLength = end - start - 3;\n        this.execute = PacketParser.prototype.executePayload;\n        return;\n      }\n    }\n    if (end - start > 0) {\n      // there is start of length header, but it's not full 3 bytes\n      this.headerLen = end - start; // 1 or 2 bytes\n      this.length = chunk[start];\n      if (this.headerLen === 2) {\n        this.length = chunk[start] + (chunk[start + 1] << 8);\n        this.execute = PacketParser.prototype.executeHeader3;\n      } else {\n        this.execute = PacketParser.prototype.executeHeader2;\n      }\n    }\n  }\n\n  executePayload(chunk) {\n    let start = 0;\n    const end = chunk.length;\n    const remainingPayload =\n      this.length - this.bufferLength + this.packetHeaderLength - 3;\n    if (end - start >= remainingPayload) {\n      // last chunk for payload\n      const payload = Buffer.allocUnsafe(this.length + this.packetHeaderLength);\n      let offset = 3;\n      for (let i = 0; i < this.buffer.length; ++i) {\n        this.buffer[i].copy(payload, offset);\n        offset += this.buffer[i].length;\n      }\n      chunk.copy(payload, offset, start, start + remainingPayload);\n      const sequenceId = payload[3];\n      if (\n        this.length < MAX_PACKET_LENGTH &&\n        this.largePacketParts.length === 0\n      ) {\n        this.onPacket(\n          new Packet(\n            sequenceId,\n            payload,\n            0,\n            this.length + this.packetHeaderLength\n          )\n        );\n      } else {\n        // first large packet - remember it's id\n        if (this.largePacketParts.length === 0) {\n          this.firstPacketSequenceId = sequenceId;\n        }\n        this.largePacketParts.push(\n          payload.slice(\n            this.packetHeaderLength,\n            this.packetHeaderLength + this.length\n          )\n        );\n        if (this.length < MAX_PACKET_LENGTH) {\n          this._flushLargePacket();\n        }\n      }\n      this.buffer = [];\n      this.bufferLength = 0;\n      this.execute = PacketParser.prototype.executeStart;\n      start += remainingPayload;\n      if (end - start > 0) {\n        return this.execute(chunk.slice(start, end));\n      }\n    } else {\n      this.buffer.push(chunk);\n      this.bufferLength += chunk.length;\n    }\n    return null;\n  }\n\n  executeHeader2(chunk) {\n    this.length += chunk[0] << 8;\n    if (chunk.length > 1) {\n      this.length += chunk[1] << 16;\n      this.execute = PacketParser.prototype.executePayload;\n      return this.executePayload(chunk.slice(2));\n    } \n    this.execute = PacketParser.prototype.executeHeader3;\n    \n    return null;\n  }\n\n  executeHeader3(chunk) {\n    this.length += chunk[0] << 16;\n    this.execute = PacketParser.prototype.executePayload;\n    return this.executePayload(chunk.slice(1));\n  }\n}\n\nmodule.exports = PacketParser;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAE7C,MAAMC,iBAAiB,GAAG,QAAQ;AAElC,SAASC,gBAAgBA,CAACC,CAAC,EAAEC,GAAG,EAAE;EAChC,MAAMC,EAAE,GAAGF,CAAC,CAACC,GAAG,CAAC;EACjB,MAAME,EAAE,GAAGH,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC;EACrB,MAAMG,EAAE,GAAGJ,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC;EACrB,IAAIE,EAAE,GAAGC,EAAE,KAAK,CAAC,EAAE;IACjB,OAAOF,EAAE;EACX;EACA,OAAOA,EAAE,IAAIC,EAAE,IAAI,CAAC,CAAC,IAAIC,EAAE,IAAI,EAAE,CAAC;AACpC;AAEA,MAAMC,YAAY,CAAC;EACjBC,WAAWA,CAACC,QAAQ,EAAEC,kBAAkB,EAAE;IACxC;IACA,IAAI,OAAOA,kBAAkB,KAAK,WAAW,EAAE;MAC7CA,kBAAkB,GAAG,CAAC;IACxB;IACA;IACA;IACA,IAAI,CAACC,MAAM,GAAG,EAAE;IAChB;IACA,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACF,kBAAkB,GAAGA,kBAAkB;IAC5C;IACA,IAAI,CAACG,SAAS,GAAG,CAAC;IAClB;IACA,IAAI,CAACC,MAAM,GAAG,CAAC;IACf,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACP,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACQ,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACC,YAAY;IAClD,IAAI,CAACC,iBAAiB,GACpBV,kBAAkB,KAAK,CAAC,GACpB,IAAI,CAACW,kBAAkB,GACvB,IAAI,CAACC,kBAAkB;EAC/B;EAEAA,kBAAkBA,CAAA,EAAG;IACnB,MAAMC,UAAU,GAAG,IAAI,CAACR,gBAAgB,CAACD,MAAM;IAC/C,IAAI,CAACC,gBAAgB,CAACS,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC1D,MAAMC,IAAI,GAAGF,MAAM,CAACG,MAAM,CAAC,IAAI,CAACb,gBAAgB,CAAC;IACjD,MAAMc,MAAM,GAAG,IAAI/B,MAAM,CAAC,IAAI,CAACkB,qBAAqB,EAAEW,IAAI,EAAE,CAAC,EAAEA,IAAI,CAACb,MAAM,CAAC;IAC3E,IAAI,CAACC,gBAAgB,CAACD,MAAM,GAAG,CAAC;IAChCe,MAAM,CAACN,UAAU,GAAGA,UAAU;IAC9B,IAAI,CAACd,QAAQ,CAACoB,MAAM,CAAC;EACvB;EAEAR,kBAAkBA,CAAA,EAAG;IACnB,MAAME,UAAU,GAAG,IAAI,CAACR,gBAAgB,CAACD,MAAM;IAC/C,IAAI,CAACC,gBAAgB,CAACS,OAAO,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACnE,MAAMC,IAAI,GAAGF,MAAM,CAACG,MAAM,CAAC,IAAI,CAACb,gBAAgB,CAAC;IACjD,IAAI,CAACA,gBAAgB,CAACD,MAAM,GAAG,CAAC;IAChC,MAAMe,MAAM,GAAG,IAAI/B,MAAM,CAAC,IAAI,CAACkB,qBAAqB,EAAEW,IAAI,EAAE,CAAC,EAAEA,IAAI,CAACb,MAAM,CAAC;IAC3Ee,MAAM,CAACN,UAAU,GAAGA,UAAU;IAC9B,IAAI,CAACd,QAAQ,CAACoB,MAAM,CAAC;EACvB;EAEAV,YAAYA,CAACW,KAAK,EAAE;IAClB,IAAIC,KAAK,GAAG,CAAC;IACb,MAAMC,GAAG,GAAGF,KAAK,CAAChB,MAAM;IACxB,OAAOkB,GAAG,GAAGD,KAAK,IAAI,CAAC,EAAE;MACvB,IAAI,CAACjB,MAAM,GAAGb,gBAAgB,CAAC6B,KAAK,EAAEC,KAAK,CAAC;MAC5C,IAAIC,GAAG,GAAGD,KAAK,IAAI,IAAI,CAACjB,MAAM,GAAG,IAAI,CAACJ,kBAAkB,EAAE;QACxD;QACA,MAAMuB,UAAU,GAAGH,KAAK,CAACC,KAAK,GAAG,CAAC,CAAC;QACnC,IACE,IAAI,CAACjB,MAAM,GAAGd,iBAAiB,IAC/B,IAAI,CAACe,gBAAgB,CAACD,MAAM,KAAK,CAAC,EAClC;UACA,IAAI,CAACL,QAAQ,CACX,IAAIX,MAAM,CACRmC,UAAU,EACVH,KAAK,EACLC,KAAK,EACLA,KAAK,GAAG,IAAI,CAACrB,kBAAkB,GAAG,IAAI,CAACI,MACzC,CACF,CAAC;QACH,CAAC,MAAM;UACL;UACA,IAAI,IAAI,CAACC,gBAAgB,CAACD,MAAM,KAAK,CAAC,EAAE;YACtC,IAAI,CAACE,qBAAqB,GAAGiB,UAAU;UACzC;UACA,IAAI,CAAClB,gBAAgB,CAACmB,IAAI,CACxBJ,KAAK,CAACK,KAAK,CACTJ,KAAK,GAAG,IAAI,CAACrB,kBAAkB,EAC/BqB,KAAK,GAAG,IAAI,CAACrB,kBAAkB,GAAG,IAAI,CAACI,MACzC,CACF,CAAC;UACD,IAAI,IAAI,CAACA,MAAM,GAAGd,iBAAiB,EAAE;YACnC,IAAI,CAACoB,iBAAiB,CAAC,CAAC;UAC1B;QACF;QACAW,KAAK,IAAI,IAAI,CAACrB,kBAAkB,GAAG,IAAI,CAACI,MAAM;MAChD,CAAC,MAAM;QACL;QACA,IAAI,CAACH,MAAM,GAAG,CAACmB,KAAK,CAACK,KAAK,CAACJ,KAAK,GAAG,CAAC,EAAEC,GAAG,CAAC,CAAC;QAC3C,IAAI,CAACpB,YAAY,GAAGoB,GAAG,GAAGD,KAAK,GAAG,CAAC;QACnC,IAAI,CAACd,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACkB,cAAc;QACpD;MACF;IACF;IACA,IAAIJ,GAAG,GAAGD,KAAK,GAAG,CAAC,EAAE;MACnB;MACA,IAAI,CAAClB,SAAS,GAAGmB,GAAG,GAAGD,KAAK,CAAC,CAAC;MAC9B,IAAI,CAACjB,MAAM,GAAGgB,KAAK,CAACC,KAAK,CAAC;MAC1B,IAAI,IAAI,CAAClB,SAAS,KAAK,CAAC,EAAE;QACxB,IAAI,CAACC,MAAM,GAAGgB,KAAK,CAACC,KAAK,CAAC,IAAID,KAAK,CAACC,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QACpD,IAAI,CAACd,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACmB,cAAc;MACtD,CAAC,MAAM;QACL,IAAI,CAACpB,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACoB,cAAc;MACtD;IACF;EACF;EAEAF,cAAcA,CAACN,KAAK,EAAE;IACpB,IAAIC,KAAK,GAAG,CAAC;IACb,MAAMC,GAAG,GAAGF,KAAK,CAAChB,MAAM;IACxB,MAAMyB,gBAAgB,GACpB,IAAI,CAACzB,MAAM,GAAG,IAAI,CAACF,YAAY,GAAG,IAAI,CAACF,kBAAkB,GAAG,CAAC;IAC/D,IAAIsB,GAAG,GAAGD,KAAK,IAAIQ,gBAAgB,EAAE;MACnC;MACA,MAAMC,OAAO,GAAGf,MAAM,CAACgB,WAAW,CAAC,IAAI,CAAC3B,MAAM,GAAG,IAAI,CAACJ,kBAAkB,CAAC;MACzE,IAAIgC,MAAM,GAAG,CAAC;MACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChC,MAAM,CAACG,MAAM,EAAE,EAAE6B,CAAC,EAAE;QAC3C,IAAI,CAAChC,MAAM,CAACgC,CAAC,CAAC,CAACC,IAAI,CAACJ,OAAO,EAAEE,MAAM,CAAC;QACpCA,MAAM,IAAI,IAAI,CAAC/B,MAAM,CAACgC,CAAC,CAAC,CAAC7B,MAAM;MACjC;MACAgB,KAAK,CAACc,IAAI,CAACJ,OAAO,EAAEE,MAAM,EAAEX,KAAK,EAAEA,KAAK,GAAGQ,gBAAgB,CAAC;MAC5D,MAAMN,UAAU,GAAGO,OAAO,CAAC,CAAC,CAAC;MAC7B,IACE,IAAI,CAAC1B,MAAM,GAAGd,iBAAiB,IAC/B,IAAI,CAACe,gBAAgB,CAACD,MAAM,KAAK,CAAC,EAClC;QACA,IAAI,CAACL,QAAQ,CACX,IAAIX,MAAM,CACRmC,UAAU,EACVO,OAAO,EACP,CAAC,EACD,IAAI,CAAC1B,MAAM,GAAG,IAAI,CAACJ,kBACrB,CACF,CAAC;MACH,CAAC,MAAM;QACL;QACA,IAAI,IAAI,CAACK,gBAAgB,CAACD,MAAM,KAAK,CAAC,EAAE;UACtC,IAAI,CAACE,qBAAqB,GAAGiB,UAAU;QACzC;QACA,IAAI,CAAClB,gBAAgB,CAACmB,IAAI,CACxBM,OAAO,CAACL,KAAK,CACX,IAAI,CAACzB,kBAAkB,EACvB,IAAI,CAACA,kBAAkB,GAAG,IAAI,CAACI,MACjC,CACF,CAAC;QACD,IAAI,IAAI,CAACA,MAAM,GAAGd,iBAAiB,EAAE;UACnC,IAAI,CAACoB,iBAAiB,CAAC,CAAC;QAC1B;MACF;MACA,IAAI,CAACT,MAAM,GAAG,EAAE;MAChB,IAAI,CAACC,YAAY,GAAG,CAAC;MACrB,IAAI,CAACK,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACC,YAAY;MAClDY,KAAK,IAAIQ,gBAAgB;MACzB,IAAIP,GAAG,GAAGD,KAAK,GAAG,CAAC,EAAE;QACnB,OAAO,IAAI,CAACd,OAAO,CAACa,KAAK,CAACK,KAAK,CAACJ,KAAK,EAAEC,GAAG,CAAC,CAAC;MAC9C;IACF,CAAC,MAAM;MACL,IAAI,CAACrB,MAAM,CAACuB,IAAI,CAACJ,KAAK,CAAC;MACvB,IAAI,CAAClB,YAAY,IAAIkB,KAAK,CAAChB,MAAM;IACnC;IACA,OAAO,IAAI;EACb;EAEAwB,cAAcA,CAACR,KAAK,EAAE;IACpB,IAAI,CAAChB,MAAM,IAAIgB,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC;IAC5B,IAAIA,KAAK,CAAChB,MAAM,GAAG,CAAC,EAAE;MACpB,IAAI,CAACA,MAAM,IAAIgB,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;MAC7B,IAAI,CAACb,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACkB,cAAc;MACpD,OAAO,IAAI,CAACA,cAAc,CAACN,KAAK,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5C;IACA,IAAI,CAAClB,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACmB,cAAc;IAEpD,OAAO,IAAI;EACb;EAEAA,cAAcA,CAACP,KAAK,EAAE;IACpB,IAAI,CAAChB,MAAM,IAAIgB,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;IAC7B,IAAI,CAACb,OAAO,GAAGV,YAAY,CAACW,SAAS,CAACkB,cAAc;IACpD,OAAO,IAAI,CAACA,cAAc,CAACN,KAAK,CAACK,KAAK,CAAC,CAAC,CAAC,CAAC;EAC5C;AACF;AAEAU,MAAM,CAACC,OAAO,GAAGvC,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}