{"ast":null,"code":"'use strict';\n\nconst process = require('process');\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return clusterIds => clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n};\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n        return;\n      }\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n\n  /**\n   * pool cluster execute\n   * @param {*} sql \n   * @param {*} values \n   * @param {*} cb \n   */\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId = foundNodeIds.length === 1 ? foundNodeIds[0] : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry = typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({\n          config: new PoolConfig(config)\n        })\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n  end(callback) {\n    const cb = callback !== undefined ? callback : err => {\n      if (err) {\n        throw err;\n      }\n    };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this._closed = true;\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end(onEnd);\n    }\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n    let foundNodeIds;\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id => id.startsWith(keyword));\n    }\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n        delete this._nodes[node.id];\n        this._clearFindCaches();\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err);\n          // eslint-disable-next-line no-console\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\nmodule.exports = PoolCluster;","map":{"version":3,"names":["process","require","Pool","PoolConfig","Connection","EventEmitter","makeSelector","RR","index","clusterIds","length","RANDOM","Math","floor","random","ORDER","PoolNamespace","constructor","cluster","pattern","selector","_cluster","_pattern","_selector","getConnection","cb","clusterNode","_getClusterNode","Error","_getConnection","err","connection","query","sql","values","createQuery","conn","onResult","emit","once","release","e","execute","foundNodeIds","_findNodeIds","nodeId","_getNode","PoolCluster","config","_canRetry","canRetry","_removeNodeErrorCount","removeNodeErrorCount","_defaultSelector","defaultSelector","_closed","_lastId","_nodes","_serviceableNodeIds","_namespaces","_findCaches","of","toUpperCase","key","add","id","errorCount","pool","push","_clearFindCaches","namespace","end","callback","undefined","nextTick","calledBack","waitingClose","onEnd","indexOf","keyword","substring","filter","startsWith","_increaseErrorCount","node","splice","_decreaseErrorCount","console","warn","_clusterId","module","exports"],"sources":["C:/Users/runes/FYP/myfoodchoice/node_modules/mysql2/lib/pool_cluster.js"],"sourcesContent":["'use strict';\n\nconst process = require('process');\n\nconst Pool = require('./pool.js');\nconst PoolConfig = require('./pool_config.js');\nconst Connection = require('./connection.js');\nconst EventEmitter = require('events').EventEmitter;\n\n/**\n * Selector\n */\nconst makeSelector = {\n  RR() {\n    let index = 0;\n    return clusterIds => clusterIds[index++ % clusterIds.length];\n  },\n  RANDOM() {\n    return clusterIds =>\n      clusterIds[Math.floor(Math.random() * clusterIds.length)];\n  },\n  ORDER() {\n    return clusterIds => clusterIds[0];\n  }\n};\n\nclass PoolNamespace {\n  constructor(cluster, pattern, selector) {\n    this._cluster = cluster;\n    this._pattern = pattern;\n    this._selector = makeSelector[selector]();\n  }\n\n  getConnection(cb) {\n    const clusterNode = this._getClusterNode();\n    if (clusterNode === null) {\n      return cb(new Error('Pool does Not exists.'));\n    }\n    return this._cluster._getConnection(clusterNode, (err, connection) => {\n      if (err) {\n        return cb(err);\n      }\n      if (connection === 'retry') {\n        return this.getConnection(cb);\n      }\n      return cb(null, connection);\n    });\n  }\n\n  /**\n   * pool cluster query\n   * @param {*} sql\n   * @param {*} values\n   * @param {*} cb\n   * @returns query\n   */\n  query(sql, values, cb) {\n    const query = Connection.createQuery(sql, values, cb, {});\n    this.getConnection((err, conn) => {\n      if (err) {\n        if (typeof query.onResult === 'function') {\n          query.onResult(err);\n        } else {\n          query.emit('error', err);\n        }\n        return;\n      }\n      try {\n        conn.query(query).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n    return query;\n  }\n\n  /**\n   * pool cluster execute\n   * @param {*} sql \n   * @param {*} values \n   * @param {*} cb \n   */\n  execute(sql, values, cb) {\n    if (typeof values === 'function') {\n      cb = values;\n      values = [];\n    }\n    this.getConnection((err, conn) => {\n      if (err) {\n        return cb(err);\n      }\n      try {\n        conn.execute(sql, values, cb).once('end', () => {\n          conn.release();\n        });\n      } catch (e) {\n        conn.release();\n        throw e;\n      }\n    });\n  }\n\n  _getClusterNode() {\n    const foundNodeIds = this._cluster._findNodeIds(this._pattern);\n    if (foundNodeIds.length === 0) {\n      return null;\n    }\n    const nodeId =\n      foundNodeIds.length === 1\n        ? foundNodeIds[0]\n        : this._selector(foundNodeIds);\n    return this._cluster._getNode(nodeId);\n  }\n}\n\nclass PoolCluster extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this._canRetry =\n      typeof config.canRetry === 'undefined' ? true : config.canRetry;\n    this._removeNodeErrorCount = config.removeNodeErrorCount || 5;\n    this._defaultSelector = config.defaultSelector || 'RR';\n    this._closed = false;\n    this._lastId = 0;\n    this._nodes = {};\n    this._serviceableNodeIds = [];\n    this._namespaces = {};\n    this._findCaches = {};\n  }\n\n  of(pattern, selector) {\n    pattern = pattern || '*';\n    selector = selector || this._defaultSelector;\n    selector = selector.toUpperCase();\n    if (!makeSelector[selector] === 'undefined') {\n      selector = this._defaultSelector;\n    }\n    const key = pattern + selector;\n    if (typeof this._namespaces[key] === 'undefined') {\n      this._namespaces[key] = new PoolNamespace(this, pattern, selector);\n    }\n    return this._namespaces[key];\n  }\n\n  add(id, config) {\n    if (typeof id === 'object') {\n      config = id;\n      id = `CLUSTER::${++this._lastId}`;\n    }\n    if (typeof this._nodes[id] === 'undefined') {\n      this._nodes[id] = {\n        id: id,\n        errorCount: 0,\n        pool: new Pool({ config: new PoolConfig(config) })\n      };\n      this._serviceableNodeIds.push(id);\n      this._clearFindCaches();\n    }\n  }\n\n  getConnection(pattern, selector, cb) {\n    let namespace;\n    if (typeof pattern === 'function') {\n      cb = pattern;\n      namespace = this.of();\n    } else {\n      if (typeof selector === 'function') {\n        cb = selector;\n        selector = this._defaultSelector;\n      }\n      namespace = this.of(pattern, selector);\n    }\n    namespace.getConnection(cb);\n  }\n\n  end(callback) {\n    const cb =\n      callback !== undefined\n        ? callback\n        : err => {\n          if (err) {\n            throw err;\n          }\n        };\n    if (this._closed) {\n      process.nextTick(cb);\n      return;\n    }\n    this._closed = true;\n\n    let calledBack = false;\n    let waitingClose = 0;\n    const onEnd = err => {\n      if (!calledBack && (err || --waitingClose <= 0)) {\n        calledBack = true;\n        return cb(err);\n      }\n    };\n\n    for (const id in this._nodes) {\n      waitingClose++;\n      this._nodes[id].pool.end(onEnd);\n    }\n    if (waitingClose === 0) {\n      process.nextTick(onEnd);\n    }\n  }\n\n  _findNodeIds(pattern) {\n    if (typeof this._findCaches[pattern] !== 'undefined') {\n      return this._findCaches[pattern];\n    }\n    let foundNodeIds;\n    if (pattern === '*') {\n      // all\n      foundNodeIds = this._serviceableNodeIds;\n    } else if (this._serviceableNodeIds.indexOf(pattern) !== -1) {\n      // one\n      foundNodeIds = [pattern];\n    } else {\n      // wild matching\n      const keyword = pattern.substring(pattern.length - 1, 0);\n      foundNodeIds = this._serviceableNodeIds.filter(id =>\n        id.startsWith(keyword)\n      );\n    }\n    this._findCaches[pattern] = foundNodeIds;\n    return foundNodeIds;\n  }\n\n  _getNode(id) {\n    return this._nodes[id] || null;\n  }\n\n  _increaseErrorCount(node) {\n    if (++node.errorCount >= this._removeNodeErrorCount) {\n      const index = this._serviceableNodeIds.indexOf(node.id);\n      if (index !== -1) {\n        this._serviceableNodeIds.splice(index, 1);\n        delete this._nodes[node.id];\n        this._clearFindCaches();\n        node.pool.end();\n        this.emit('remove', node.id);\n      }\n    }\n  }\n\n  _decreaseErrorCount(node) {\n    if (node.errorCount > 0) {\n      --node.errorCount;\n    }\n  }\n\n  _getConnection(node, cb) {\n    node.pool.getConnection((err, connection) => {\n      if (err) {\n        this._increaseErrorCount(node);\n        if (this._canRetry) {\n          // REVIEW: this seems wrong?\n          this.emit('warn', err);\n          // eslint-disable-next-line no-console\n          console.warn(`[Error] PoolCluster : ${err}`);\n          return cb(null, 'retry');\n        }\n        return cb(err);\n      }\n      this._decreaseErrorCount(node);\n\n      connection._clusterId = node.id;\n      return cb(null, connection);\n    });\n  }\n\n  _clearFindCaches() {\n    this._findCaches = {};\n  }\n}\n\nmodule.exports = PoolCluster;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}