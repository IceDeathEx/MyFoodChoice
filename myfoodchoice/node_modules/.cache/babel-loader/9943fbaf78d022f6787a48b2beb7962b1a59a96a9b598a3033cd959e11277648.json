{"ast":null,"code":"'use strict';\n\n// TODO: rename to OK packet\n// https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html\nconst Packet = require('./packet.js');\nconst ClientConstants = require('../constants/client.js');\nconst ServerSatusFlags = require('../constants/server_status.js');\nconst EncodingToCharset = require('../constants/encoding_charset.js');\nconst sessionInfoTypes = require('../constants/session_track.js');\nclass ResultSetHeader {\n  constructor(packet, connection) {\n    const bigNumberStrings = connection.config.bigNumberStrings;\n    const encoding = connection.serverEncoding;\n    const flags = connection._handshakePacket.capabilityFlags;\n    const isSet = function (flag) {\n      return flags & ClientConstants[flag];\n    };\n    if (packet.buffer[packet.offset] !== 0) {\n      this.fieldCount = packet.readLengthCodedNumber();\n      if (this.fieldCount === null) {\n        this.infileName = packet.readString(undefined, encoding);\n      }\n      return;\n    }\n    this.fieldCount = packet.readInt8(); // skip OK byte\n    this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);\n    this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);\n    this.info = '';\n    if (isSet('PROTOCOL_41')) {\n      this.serverStatus = packet.readInt16();\n      this.warningStatus = packet.readInt16();\n    } else if (isSet('TRANSACTIONS')) {\n      this.serverStatus = packet.readInt16();\n    }\n    let stateChanges = null;\n    if (isSet('SESSION_TRACK') && packet.offset < packet.end) {\n      this.info = packet.readLengthCodedString(encoding);\n      if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {\n        // session change info record - see\n        // https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html#cs-sect-packet-ok-sessioninfo\n        let len = packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;\n        const end = packet.offset + len;\n        let type, key, stateEnd;\n        if (len > 0) {\n          stateChanges = {\n            systemVariables: {},\n            schema: null,\n            gtids: [],\n            trackStateChange: null\n          };\n        }\n        while (packet.offset < end) {\n          type = packet.readInt8();\n          len = packet.readLengthCodedNumber();\n          stateEnd = packet.offset + len;\n          if (type === sessionInfoTypes.SYSTEM_VARIABLES) {\n            key = packet.readLengthCodedString(encoding);\n            const val = packet.readLengthCodedString(encoding);\n            stateChanges.systemVariables[key] = val;\n            if (key === 'character_set_client') {\n              const charsetNumber = EncodingToCharset[val];\n              connection.config.charsetNumber = charsetNumber;\n            }\n          } else if (type === sessionInfoTypes.SCHEMA) {\n            key = packet.readLengthCodedString(encoding);\n            stateChanges.schema = key;\n          } else if (type === sessionInfoTypes.STATE_CHANGE) {\n            stateChanges.trackStateChange = packet.readLengthCodedString(encoding);\n          } else if (type === sessionInfoTypes.STATE_GTIDS) {\n            // TODO: find if the first length coded string means anything. Usually comes as empty\n            // eslint-disable-next-line no-unused-vars\n            const _unknownString = packet.readLengthCodedString(encoding);\n            const gtid = packet.readLengthCodedString(encoding);\n            stateChanges.gtids = gtid.split(',');\n          } else {\n            // unsupported session track type. For now just ignore\n          }\n          packet.offset = stateEnd;\n        }\n      }\n    } else {\n      this.info = packet.readString(undefined, encoding);\n    }\n    if (stateChanges) {\n      this.stateChanges = stateChanges;\n    }\n    const m = this.info.match(/\\schanged:\\s*(\\d+)/i);\n    if (m !== null) {\n      this.changedRows = parseInt(m[1], 10);\n    } else {\n      this.changedRows = 0;\n    }\n  }\n\n  // TODO: should be consistent instance member, but it's just easier here to have just function\n  static toPacket(fieldCount, insertId) {\n    let length = 4 + Packet.lengthCodedNumberLength(fieldCount);\n    if (typeof insertId !== 'undefined') {\n      length += Packet.lengthCodedNumberLength(insertId);\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeLengthCodedNumber(fieldCount);\n    if (typeof insertId !== 'undefined') {\n      packet.writeLengthCodedNumber(insertId);\n    }\n    return packet;\n  }\n}\nmodule.exports = ResultSetHeader;","map":{"version":3,"names":["Packet","require","ClientConstants","ServerSatusFlags","EncodingToCharset","sessionInfoTypes","ResultSetHeader","constructor","packet","connection","bigNumberStrings","config","encoding","serverEncoding","flags","_handshakePacket","capabilityFlags","isSet","flag","buffer","offset","fieldCount","readLengthCodedNumber","infileName","readString","undefined","readInt8","affectedRows","insertId","readLengthCodedNumberSigned","info","serverStatus","readInt16","warningStatus","stateChanges","end","readLengthCodedString","SERVER_SESSION_STATE_CHANGED","len","type","key","stateEnd","systemVariables","schema","gtids","trackStateChange","SYSTEM_VARIABLES","val","charsetNumber","SCHEMA","STATE_CHANGE","STATE_GTIDS","_unknownString","gtid","split","m","match","changedRows","parseInt","toPacket","length","lengthCodedNumberLength","Buffer","allocUnsafe","writeLengthCodedNumber","module","exports"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/mysql2/lib/packets/resultset_header.js"],"sourcesContent":["'use strict';\n\n// TODO: rename to OK packet\n// https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html\n\nconst Packet = require('./packet.js');\nconst ClientConstants = require('../constants/client.js');\nconst ServerSatusFlags = require('../constants/server_status.js');\n\nconst EncodingToCharset = require('../constants/encoding_charset.js');\nconst sessionInfoTypes = require('../constants/session_track.js');\n\nclass ResultSetHeader {\n  constructor(packet, connection) {\n    const bigNumberStrings = connection.config.bigNumberStrings;\n    const encoding = connection.serverEncoding;\n    const flags = connection._handshakePacket.capabilityFlags;\n    const isSet = function(flag) {\n      return flags & ClientConstants[flag];\n    };\n    if (packet.buffer[packet.offset] !== 0) {\n      this.fieldCount = packet.readLengthCodedNumber();\n      if (this.fieldCount === null) {\n        this.infileName = packet.readString(undefined, encoding);\n      }\n      return;\n    }\n    this.fieldCount = packet.readInt8(); // skip OK byte\n    this.affectedRows = packet.readLengthCodedNumber(bigNumberStrings);\n    this.insertId = packet.readLengthCodedNumberSigned(bigNumberStrings);\n    this.info = '';\n    if (isSet('PROTOCOL_41')) {\n      this.serverStatus = packet.readInt16();\n      this.warningStatus = packet.readInt16();\n    } else if (isSet('TRANSACTIONS')) {\n      this.serverStatus = packet.readInt16();\n    }\n    let stateChanges = null;\n    if (isSet('SESSION_TRACK') && packet.offset < packet.end) {\n      this.info = packet.readLengthCodedString(encoding);\n\n      if (this.serverStatus && ServerSatusFlags.SERVER_SESSION_STATE_CHANGED) {\n        // session change info record - see\n        // https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html#cs-sect-packet-ok-sessioninfo\n        let len =\n          packet.offset < packet.end ? packet.readLengthCodedNumber() : 0;\n        const end = packet.offset + len;\n        let type, key, stateEnd;\n        if (len > 0) {\n          stateChanges = {\n            systemVariables: {},\n            schema: null,\n            gtids: [],\n            trackStateChange: null\n          };\n        }\n        while (packet.offset < end) {\n          type = packet.readInt8();\n          len = packet.readLengthCodedNumber();\n          stateEnd = packet.offset + len;\n          if (type === sessionInfoTypes.SYSTEM_VARIABLES) {\n            key = packet.readLengthCodedString(encoding);\n            const val = packet.readLengthCodedString(encoding);\n            stateChanges.systemVariables[key] = val;\n            if (key === 'character_set_client') {\n              const charsetNumber = EncodingToCharset[val];\n              connection.config.charsetNumber = charsetNumber;\n            }\n          } else if (type === sessionInfoTypes.SCHEMA) {\n            key = packet.readLengthCodedString(encoding);\n            stateChanges.schema = key;\n          } else if (type === sessionInfoTypes.STATE_CHANGE) {\n            stateChanges.trackStateChange = packet.readLengthCodedString(\n              encoding\n            );\n          } else if (type === sessionInfoTypes.STATE_GTIDS) {\n            // TODO: find if the first length coded string means anything. Usually comes as empty\n            // eslint-disable-next-line no-unused-vars\n            const _unknownString = packet.readLengthCodedString(encoding);\n            const gtid = packet.readLengthCodedString(encoding);\n            stateChanges.gtids = gtid.split(',');\n          } else {\n            // unsupported session track type. For now just ignore\n          }\n          packet.offset = stateEnd;\n        }\n      }\n    } else {\n      this.info = packet.readString(undefined, encoding);\n    }\n    if (stateChanges) {\n      this.stateChanges = stateChanges;\n    }\n    const m = this.info.match(/\\schanged:\\s*(\\d+)/i);\n    if (m !== null) {\n      this.changedRows = parseInt(m[1], 10);\n    } else {\n      this.changedRows = 0;\n    }\n  }\n\n  // TODO: should be consistent instance member, but it's just easier here to have just function\n  static toPacket(fieldCount, insertId) {\n    let length = 4 + Packet.lengthCodedNumberLength(fieldCount);\n    if (typeof insertId !== 'undefined') {\n      length += Packet.lengthCodedNumberLength(insertId);\n    }\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(0, buffer, 0, length);\n    packet.offset = 4;\n    packet.writeLengthCodedNumber(fieldCount);\n    if (typeof insertId !== 'undefined') {\n      packet.writeLengthCodedNumber(insertId);\n    }\n    return packet;\n  }\n}\n\nmodule.exports = ResultSetHeader;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}