{"ast":null,"code":"'use strict';\n\nconst Packet = require('../packets/packet');\nconst StringParser = require('../parsers/string');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst fields = ['catalog', 'schema', 'table', 'orgTable', 'name', 'orgName'];\n\n// creating JS string is relatively expensive (compared to\n// reading few bytes from buffer) because all string properties\n// except for name are unlikely to be used we postpone\n// string conversion until property access\n//\n// TODO: watch for integration benchmarks (one with real network buffer)\n// there could be bad side effect as keeping reference to a buffer makes it\n// sit in the memory longer (usually until final .query() callback)\n// Latest v8 perform much better in regard to bufferer -> string conversion,\n// at some point of time this optimisation might become unnecessary\n// see https://github.com/sidorares/node-mysql2/pull/137\n//\nclass ColumnDefinition {\n  constructor(packet, clientEncoding) {\n    this._buf = packet.buffer;\n    this._clientEncoding = clientEncoding;\n    this._catalogLength = packet.readLengthCodedNumber();\n    this._catalogStart = packet.offset;\n    packet.offset += this._catalogLength;\n    this._schemaLength = packet.readLengthCodedNumber();\n    this._schemaStart = packet.offset;\n    packet.offset += this._schemaLength;\n    this._tableLength = packet.readLengthCodedNumber();\n    this._tableStart = packet.offset;\n    packet.offset += this._tableLength;\n    this._orgTableLength = packet.readLengthCodedNumber();\n    this._orgTableStart = packet.offset;\n    packet.offset += this._orgTableLength;\n    // name is always used, don't make it lazy\n    const _nameLength = packet.readLengthCodedNumber();\n    const _nameStart = packet.offset;\n    packet.offset += _nameLength;\n    this._orgNameLength = packet.readLengthCodedNumber();\n    this._orgNameStart = packet.offset;\n    packet.offset += this._orgNameLength;\n    packet.skip(1); //  length of the following fields (always 0x0c)\n    this.characterSet = packet.readInt16();\n    this.encoding = CharsetToEncoding[this.characterSet];\n    this.name = StringParser.decode(this._buf, this.encoding === 'binary' ? this._clientEncoding : this.encoding, _nameStart, _nameStart + _nameLength);\n    this.columnLength = packet.readInt32();\n    this.columnType = packet.readInt8();\n    this.type = this.columnType;\n    this.flags = packet.readInt16();\n    this.decimals = packet.readInt8();\n  }\n  inspect() {\n    return {\n      catalog: this.catalog,\n      schema: this.schema,\n      name: this.name,\n      orgName: this.orgName,\n      table: this.table,\n      orgTable: this.orgTable,\n      characterSet: this.characterSet,\n      encoding: this.encoding,\n      columnLength: this.columnLength,\n      type: this.columnType,\n      flags: this.flags,\n      decimals: this.decimals\n    };\n  }\n  [Symbol.for('nodejs.util.inspect.custom')](depth, inspectOptions, inspect) {\n    const Types = require('../constants/types.js');\n    const typeNames = [];\n    for (const t in Types) {\n      typeNames[Types[t]] = t;\n    }\n    const fiedFlags = require('../constants/field_flags.js');\n    const flagNames = [];\n    // TODO: respect inspectOptions.showHidden\n    //const inspectFlags = inspectOptions.showHidden ? this.flags : this.flags & ~fiedFlags.PRI_KEY;\n    const inspectFlags = this.flags;\n    for (const f in fiedFlags) {\n      if (inspectFlags & fiedFlags[f]) {\n        if (f === 'PRI_KEY') {\n          flagNames.push('PRIMARY KEY');\n        } else if (f === 'NOT_NULL') {\n          flagNames.push('NOT NULL');\n        } else if (f === 'BINARY') {\n          // ignore flag for now\n        } else if (f === 'MULTIPLE_KEY') {\n          // not sure if that should be part of inspection.\n          // in the schema usually this is part of index definition\n          // example: UNIQUE KEY `my_uniq_id` (`id_box_elements`,`id_router`)\n          // note that only first column has MULTIPLE_KEY flag set in this case\n          // so there is no good way of knowing that this is part of index just \n          // by looking at indifidual field flags\n        } else if (f === 'NO_DEFAULT_VALUE') {\n          // almost the same as NOT_NULL?\n        } else if (f === 'BLOB') {\n          // included in the type\n        } else if (f === 'UNSIGNED') {\n          // this should be first after type\n        } else if (f === 'TIMESTAMP') {\n          // timestamp flag is redundant for inspection - already included in type\n        } else if (f === 'ON_UPDATE_NOW') {\n          flagNames.push('ON UPDATE CURRENT_TIMESTAMP');\n        } else {\n          flagNames.push(f);\n        }\n      }\n    }\n    if (depth > 1) {\n      return inspect({\n        ...this.inspect(),\n        typeName: typeNames[this.columnType],\n        flags: flagNames\n      });\n    }\n    const isUnsigned = this.flags & fiedFlags.UNSIGNED;\n    let typeName = typeNames[this.columnType];\n    if (typeName === 'BLOB') {\n      // TODO: check for non-utf8mb4 encoding\n      if (this.columnLength === 4294967295) {\n        typeName = 'LONGTEXT';\n      } else if (this.columnLength === 67108860) {\n        typeName = 'MEDIUMTEXT';\n      } else if (this.columnLength === 262140) {\n        typeName = 'TEXT';\n      } else if (this.columnLength === 1020) {\n        // 255*4\n        typeName = 'TINYTEXT';\n      } else {\n        typeName = `BLOB(${this.columnLength})`;\n      }\n    } else if (typeName === 'VAR_STRING') {\n      // TODO: check for non-utf8mb4 encoding\n      typeName = `VARCHAR(${Math.ceil(this.columnLength / 4)})`;\n    } else if (typeName === 'TINY') {\n      if (this.columnLength === 3 && isUnsigned || this.columnLength === 4 && !isUnsigned) {\n        typeName = 'TINYINT';\n      } else {\n        typeName = `TINYINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'LONGLONG') {\n      if (this.columnLength === 20) {\n        typeName = 'BIGINT';\n      } else {\n        typeName = `BIGINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'SHORT') {\n      if (isUnsigned && this.columnLength === 5) {\n        typeName = 'SMALLINT';\n      } else if (!isUnsigned && this.columnLength === 6) {\n        typeName = 'SMALLINT';\n      } else {\n        typeName = `SMALLINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'LONG') {\n      if (isUnsigned && this.columnLength === 10) {\n        typeName = 'INT';\n      } else if (!isUnsigned && this.columnLength === 11) {\n        typeName = 'INT';\n      } else {\n        typeName = `INT(${this.columnLength})`;\n      }\n    } else if (typeName === 'INT24') {\n      if (isUnsigned && this.columnLength === 8) {\n        typeName = 'MEDIUMINT';\n      } else if (!isUnsigned && this.columnLength === 9) {\n        typeName = 'MEDIUMINT';\n      } else {\n        typeName = `MEDIUMINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'DOUBLE') {\n      // DOUBLE without modifiers is reported as DOUBLE(22, 31)\n      if (this.columnLength === 22 && this.decimals === 31) {\n        typeName = 'DOUBLE';\n      } else {\n        typeName = `DOUBLE(${this.columnLength},${this.decimals})`;\n      }\n    } else if (typeName === 'FLOAT') {\n      // FLOAT without modifiers is reported as FLOAT(12, 31)\n      if (this.columnLength === 12 && this.decimals === 31) {\n        typeName = 'FLOAT';\n      } else {\n        typeName = `FLOAT(${this.columnLength},${this.decimals})`;\n      }\n    } else if (typeName === 'NEWDECIMAL') {\n      if (this.columnLength === 11 && this.decimals === 0) {\n        typeName = 'DECIMAL';\n      } else if (this.decimals === 0) {\n        // not sure why, but DECIMAL(13) is reported as DECIMAL(14, 0)\n        // and DECIMAL(13, 9) is reported as NEWDECIMAL(15, 9)\n        if (isUnsigned) {\n          typeName = `DECIMAL(${this.columnLength})`;\n        } else {\n          typeName = `DECIMAL(${this.columnLength - 1})`;\n        }\n      } else {\n        typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;\n      }\n    } else {\n      typeName = `${typeNames[this.columnType]}(${this.columnLength})`;\n    }\n    if (isUnsigned) {\n      typeName += ' UNSIGNED';\n    }\n\n    // TODO respect colors option\n    return `\\`${this.name}\\` ${[typeName, ...flagNames].join(' ')}`;\n  }\n  static toPacket(column, sequenceId) {\n    let length = 17; // = 4 padding + 1 + 12 for the rest\n    fields.forEach(field => {\n      length += Packet.lengthCodedStringLength(column[field], CharsetToEncoding[column.characterSet]);\n    });\n    const buffer = Buffer.allocUnsafe(length);\n    const packet = new Packet(sequenceId, buffer, 0, length);\n    function writeField(name) {\n      packet.writeLengthCodedString(column[name], CharsetToEncoding[column.characterSet]);\n    }\n    packet.offset = 4;\n    fields.forEach(writeField);\n    packet.writeInt8(0x0c);\n    packet.writeInt16(column.characterSet);\n    packet.writeInt32(column.columnLength);\n    packet.writeInt8(column.columnType);\n    packet.writeInt16(column.flags);\n    packet.writeInt8(column.decimals);\n    packet.writeInt16(0); // filler\n    return packet;\n  }\n\n  // node-mysql compatibility: alias \"db\" to \"schema\"\n  get db() {\n    return this.schema;\n  }\n}\nconst addString = function (name) {\n  Object.defineProperty(ColumnDefinition.prototype, name, {\n    get: function () {\n      const start = this[`_${name}Start`];\n      const end = start + this[`_${name}Length`];\n      const val = StringParser.decode(this._buf, this.encoding === 'binary' ? this._clientEncoding : this.encoding, start, end);\n      Object.defineProperty(this, name, {\n        value: val,\n        writable: false,\n        configurable: false,\n        enumerable: false\n      });\n      return val;\n    }\n  });\n};\naddString('catalog');\naddString('schema');\naddString('table');\naddString('orgTable');\naddString('orgName');\nmodule.exports = ColumnDefinition;","map":{"version":3,"names":["Packet","require","StringParser","CharsetToEncoding","fields","ColumnDefinition","constructor","packet","clientEncoding","_buf","buffer","_clientEncoding","_catalogLength","readLengthCodedNumber","_catalogStart","offset","_schemaLength","_schemaStart","_tableLength","_tableStart","_orgTableLength","_orgTableStart","_nameLength","_nameStart","_orgNameLength","_orgNameStart","skip","characterSet","readInt16","encoding","name","decode","columnLength","readInt32","columnType","readInt8","type","flags","decimals","inspect","catalog","schema","orgName","table","orgTable","Symbol","for","depth","inspectOptions","Types","typeNames","t","fiedFlags","flagNames","inspectFlags","f","push","typeName","isUnsigned","UNSIGNED","Math","ceil","join","toPacket","column","sequenceId","length","forEach","field","lengthCodedStringLength","Buffer","allocUnsafe","writeField","writeLengthCodedString","writeInt8","writeInt16","writeInt32","db","addString","Object","defineProperty","prototype","get","start","end","val","value","writable","configurable","enumerable","module","exports"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/mysql2/lib/packets/column_definition.js"],"sourcesContent":["'use strict';\n\nconst Packet = require('../packets/packet');\nconst StringParser = require('../parsers/string');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\n\nconst fields = ['catalog', 'schema', 'table', 'orgTable', 'name', 'orgName'];\n\n// creating JS string is relatively expensive (compared to\n// reading few bytes from buffer) because all string properties\n// except for name are unlikely to be used we postpone\n// string conversion until property access\n//\n// TODO: watch for integration benchmarks (one with real network buffer)\n// there could be bad side effect as keeping reference to a buffer makes it\n// sit in the memory longer (usually until final .query() callback)\n// Latest v8 perform much better in regard to bufferer -> string conversion,\n// at some point of time this optimisation might become unnecessary\n// see https://github.com/sidorares/node-mysql2/pull/137\n//\nclass ColumnDefinition {\n  constructor(packet, clientEncoding) {\n    this._buf = packet.buffer;\n    this._clientEncoding = clientEncoding;\n    this._catalogLength = packet.readLengthCodedNumber();\n    this._catalogStart = packet.offset;\n    packet.offset += this._catalogLength;\n    this._schemaLength = packet.readLengthCodedNumber();\n    this._schemaStart = packet.offset;\n    packet.offset += this._schemaLength;\n    this._tableLength = packet.readLengthCodedNumber();\n    this._tableStart = packet.offset;\n    packet.offset += this._tableLength;\n    this._orgTableLength = packet.readLengthCodedNumber();\n    this._orgTableStart = packet.offset;\n    packet.offset += this._orgTableLength;\n    // name is always used, don't make it lazy\n    const _nameLength = packet.readLengthCodedNumber();\n    const _nameStart = packet.offset;\n    packet.offset += _nameLength;\n    this._orgNameLength = packet.readLengthCodedNumber();\n    this._orgNameStart = packet.offset;\n    packet.offset += this._orgNameLength;\n    packet.skip(1); //  length of the following fields (always 0x0c)\n    this.characterSet = packet.readInt16();\n    this.encoding = CharsetToEncoding[this.characterSet];\n    this.name = StringParser.decode(\n      this._buf,\n      this.encoding === 'binary' ? this._clientEncoding : this.encoding,\n      _nameStart, \n      _nameStart + _nameLength\n    );\n    this.columnLength = packet.readInt32();\n    this.columnType = packet.readInt8();\n    this.type = this.columnType;\n    this.flags = packet.readInt16();\n    this.decimals = packet.readInt8();\n  }\n\n  inspect() {\n    return {\n      catalog: this.catalog,\n      schema: this.schema,\n      name: this.name,\n      orgName: this.orgName,\n      table: this.table,\n      orgTable: this.orgTable,\n      characterSet: this.characterSet,\n      encoding: this.encoding,\n      columnLength: this.columnLength,\n      type: this.columnType,\n      flags: this.flags,\n      decimals: this.decimals\n    };\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](depth, inspectOptions, inspect) {\n    const Types = require('../constants/types.js');\n    const typeNames = [];\n    for (const t in Types) {\n      typeNames[Types[t]] = t;\n    }\n    const fiedFlags = require('../constants/field_flags.js');\n    const flagNames = [];\n    // TODO: respect inspectOptions.showHidden\n    //const inspectFlags = inspectOptions.showHidden ? this.flags : this.flags & ~fiedFlags.PRI_KEY;\n    const inspectFlags = this.flags;\n    for (const f in fiedFlags) {\n      if (inspectFlags & fiedFlags[f]) {\n        if (f === 'PRI_KEY') {\n          flagNames.push('PRIMARY KEY');\n        } else if (f === 'NOT_NULL') {\n          flagNames.push('NOT NULL'); \n        } else if (f === 'BINARY') {\n          // ignore flag for now\n        } else if (f === 'MULTIPLE_KEY') {\n          // not sure if that should be part of inspection.\n          // in the schema usually this is part of index definition\n          // example: UNIQUE KEY `my_uniq_id` (`id_box_elements`,`id_router`)\n          // note that only first column has MULTIPLE_KEY flag set in this case\n          // so there is no good way of knowing that this is part of index just \n          // by looking at indifidual field flags\n        } else if (f === 'NO_DEFAULT_VALUE') {\n          // almost the same as NOT_NULL?\n        } else if (f === 'BLOB') {\n          // included in the type\n        } else if (f === 'UNSIGNED') {\n          // this should be first after type\n        } else if (f === 'TIMESTAMP') {\n          // timestamp flag is redundant for inspection - already included in type\n        } else if (f === 'ON_UPDATE_NOW') {\n          flagNames.push('ON UPDATE CURRENT_TIMESTAMP');\n        } else {\n          flagNames.push(f);\n        }\n      }\n    }\n\n    if (depth > 1) {\n      return inspect({\n        ...this.inspect(),\n        typeName: typeNames[this.columnType],\n        flags: flagNames,\n      });\n    }\n\n    const isUnsigned = this.flags & fiedFlags.UNSIGNED;\n\n    let typeName = typeNames[this.columnType];\n    if (typeName === 'BLOB') {\n      // TODO: check for non-utf8mb4 encoding\n      if (this.columnLength === 4294967295) {\n        typeName = 'LONGTEXT';\n      } else if (this.columnLength === 67108860) {\n        typeName = 'MEDIUMTEXT';\n      } else if (this.columnLength === 262140) {\n        typeName = 'TEXT';\n      } else if (this.columnLength === 1020) { // 255*4\n        typeName = 'TINYTEXT';\n      } else {\n        typeName = `BLOB(${this.columnLength})`;\n      }\n    } else if (typeName === 'VAR_STRING') {\n      // TODO: check for non-utf8mb4 encoding\n      typeName = `VARCHAR(${Math.ceil(this.columnLength/4)})`;\n    } else if (typeName === 'TINY') {\n      if (\n        (this.columnLength === 3 && isUnsigned) ||\n        (this.columnLength === 4 && !isUnsigned) ) {\n        typeName = 'TINYINT';\n      } else {\n        typeName = `TINYINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'LONGLONG') {\n      if (this.columnLength === 20) {\n        typeName = 'BIGINT';\n      } else {\n        typeName = `BIGINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'SHORT') {\n      if (isUnsigned && this.columnLength === 5) {\n        typeName = 'SMALLINT';\n      } else if (!isUnsigned && this.columnLength === 6) {\n        typeName = 'SMALLINT';\n      } else {\n        typeName = `SMALLINT(${this.columnLength})`;\n      }\n\n    } else if (typeName === 'LONG') {\n      if (isUnsigned &&  this.columnLength === 10) {\n        typeName = 'INT';\n      } else if (!isUnsigned && this.columnLength === 11) {\n        typeName = 'INT';\n      } else {\n        typeName = `INT(${this.columnLength})`;\n      }\n    } else if (typeName === 'INT24') {\n      if (isUnsigned && this.columnLength === 8) {\n        typeName = 'MEDIUMINT';\n      } else if (!isUnsigned && this.columnLength === 9) {\n        typeName = 'MEDIUMINT';\n      } else {\n        typeName = `MEDIUMINT(${this.columnLength})`;\n      }\n    } else if (typeName === 'DOUBLE') {\n      // DOUBLE without modifiers is reported as DOUBLE(22, 31)\n      if (this.columnLength === 22 && this.decimals === 31) {\n        typeName = 'DOUBLE';\n      } else {\n        typeName = `DOUBLE(${this.columnLength},${this.decimals})`;\n      }\n    } else if (typeName === 'FLOAT') {\n      // FLOAT without modifiers is reported as FLOAT(12, 31)\n      if (this.columnLength === 12 && this.decimals === 31) {\n        typeName = 'FLOAT';\n      } else {\n        typeName = `FLOAT(${this.columnLength},${this.decimals})`;\n      }\n    } else if (typeName === 'NEWDECIMAL') {\n      if (this.columnLength === 11 && this.decimals === 0) {\n        typeName = 'DECIMAL';\n      } else if (this.decimals === 0) {\n        // not sure why, but DECIMAL(13) is reported as DECIMAL(14, 0)\n        // and DECIMAL(13, 9) is reported as NEWDECIMAL(15, 9)\n        if (isUnsigned) {\n          typeName = `DECIMAL(${this.columnLength})`;\n        } else {\n          typeName = `DECIMAL(${this.columnLength - 1})`;\n        }\n      } else {\n        typeName = `DECIMAL(${this.columnLength - 2},${this.decimals})`;\n      }\n    } else {\n      typeName = `${typeNames[this.columnType]}(${this.columnLength})`;\n    }\n\n    if (isUnsigned) {\n      typeName += ' UNSIGNED';\n    }\n\n    // TODO respect colors option\n    return `\\`${this.name}\\` ${[typeName, ...flagNames].join(' ')}`;\n  }\n\n  static toPacket(column, sequenceId) {\n    let length = 17; // = 4 padding + 1 + 12 for the rest\n    fields.forEach(field => {\n      length += Packet.lengthCodedStringLength(\n        column[field],\n        CharsetToEncoding[column.characterSet]\n      );\n    });\n    const buffer = Buffer.allocUnsafe(length);\n\n    const packet = new Packet(sequenceId, buffer, 0, length);\n    function writeField(name) {\n      packet.writeLengthCodedString(\n        column[name],\n        CharsetToEncoding[column.characterSet]\n      );\n    }\n    packet.offset = 4;\n    fields.forEach(writeField);\n    packet.writeInt8(0x0c);\n    packet.writeInt16(column.characterSet);\n    packet.writeInt32(column.columnLength);\n    packet.writeInt8(column.columnType);\n    packet.writeInt16(column.flags);\n    packet.writeInt8(column.decimals);\n    packet.writeInt16(0); // filler\n    return packet;\n  }\n\n  // node-mysql compatibility: alias \"db\" to \"schema\"\n  get db() {\n    return this.schema;\n  }\n}\n\nconst addString = function(name) {\n  Object.defineProperty(ColumnDefinition.prototype, name, {\n    get: function() {\n      const start = this[`_${name}Start`];\n      const end = start + this[`_${name}Length`];\n      const val = StringParser.decode(\n        this._buf,\n        this.encoding === 'binary' ? this._clientEncoding : this.encoding,\n        start, \n        end\n      );\n      \n      Object.defineProperty(this, name, {\n        value: val,\n        writable: false,\n        configurable: false,\n        enumerable: false\n      });\n\n      return val;\n    }\n  });\n};\n\naddString('catalog');\naddString('schema');\naddString('table');\naddString('orgTable');\naddString('orgName');\n\nmodule.exports = ColumnDefinition;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}