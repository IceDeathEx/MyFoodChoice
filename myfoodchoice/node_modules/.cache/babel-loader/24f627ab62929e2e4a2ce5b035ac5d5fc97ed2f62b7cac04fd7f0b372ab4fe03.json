{"ast":null,"code":"'use strict';\n\nconst ClientConstants = require('../constants/client.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst Packet = require('../packets/packet.js');\nconst auth41 = require('../auth_41.js');\nclass HandshakeResponse {\n  constructor(handshake) {\n    this.user = handshake.user || '';\n    this.database = handshake.database || '';\n    this.password = handshake.password || '';\n    this.passwordSha1 = handshake.passwordSha1;\n    this.authPluginData1 = handshake.authPluginData1;\n    this.authPluginData2 = handshake.authPluginData2;\n    this.compress = handshake.compress;\n    this.clientFlags = handshake.flags;\n    // TODO: pre-4.1 auth support\n    let authToken;\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(this.passwordSha1, this.authPluginData1, this.authPluginData2);\n    } else {\n      authToken = auth41.calculateToken(this.password, this.authPluginData1, this.authPluginData2);\n    }\n    this.authToken = authToken;\n    this.charsetNumber = handshake.charsetNumber;\n    this.encoding = CharsetToEncoding[handshake.charsetNumber];\n    this.connectAttributes = handshake.connectAttributes;\n  }\n  serializeResponse(buffer) {\n    const isSet = flag => this.clientFlags & ClientConstants[flag];\n    const packet = new Packet(0, buffer, 0, buffer.length);\n    packet.offset = 4;\n    packet.writeInt32(this.clientFlags);\n    packet.writeInt32(0); // max packet size. todo: move to config\n    packet.writeInt8(this.charsetNumber);\n    packet.skip(23);\n    const encoding = this.encoding;\n    packet.writeNullTerminatedString(this.user, encoding);\n    let k;\n    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {\n      packet.writeLengthCodedNumber(this.authToken.length);\n      packet.writeBuffer(this.authToken);\n    } else if (isSet('SECURE_CONNECTION')) {\n      packet.writeInt8(this.authToken.length);\n      packet.writeBuffer(this.authToken);\n    } else {\n      packet.writeBuffer(this.authToken);\n      packet.writeInt8(0);\n    }\n    if (isSet('CONNECT_WITH_DB')) {\n      packet.writeNullTerminatedString(this.database, encoding);\n    }\n    if (isSet('PLUGIN_AUTH')) {\n      // TODO: pass from config\n      packet.writeNullTerminatedString('mysql_native_password', 'latin1');\n    }\n    if (isSet('CONNECT_ATTRS')) {\n      const connectAttributes = this.connectAttributes || {};\n      const attrNames = Object.keys(connectAttributes);\n      let keysLength = 0;\n      for (k = 0; k < attrNames.length; ++k) {\n        keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);\n        keysLength += Packet.lengthCodedStringLength(connectAttributes[attrNames[k]], encoding);\n      }\n      packet.writeLengthCodedNumber(keysLength);\n      for (k = 0; k < attrNames.length; ++k) {\n        packet.writeLengthCodedString(attrNames[k], encoding);\n        packet.writeLengthCodedString(connectAttributes[attrNames[k]], encoding);\n      }\n    }\n    return packet;\n  }\n  toPacket() {\n    if (typeof this.user !== 'string') {\n      throw new Error('\"user\" connection config property must be a string');\n    }\n    if (typeof this.database !== 'string') {\n      throw new Error('\"database\" connection config property must be a string');\n    }\n    // dry run: calculate resulting packet length\n    const p = this.serializeResponse(Packet.MockBuffer());\n    return this.serializeResponse(Buffer.alloc(p.offset));\n  }\n  static fromPacket(packet) {\n    const args = {};\n    args.clientFlags = packet.readInt32();\n    function isSet(flag) {\n      return args.clientFlags & ClientConstants[flag];\n    }\n    args.maxPacketSize = packet.readInt32();\n    args.charsetNumber = packet.readInt8();\n    const encoding = CharsetToEncoding[args.charsetNumber];\n    args.encoding = encoding;\n    packet.skip(23);\n    args.user = packet.readNullTerminatedString(encoding);\n    let authTokenLength;\n    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {\n      authTokenLength = packet.readLengthCodedNumber(encoding);\n      args.authToken = packet.readBuffer(authTokenLength);\n    } else if (isSet('SECURE_CONNECTION')) {\n      authTokenLength = packet.readInt8();\n      args.authToken = packet.readBuffer(authTokenLength);\n    } else {\n      args.authToken = packet.readNullTerminatedString(encoding);\n    }\n    if (isSet('CONNECT_WITH_DB')) {\n      args.database = packet.readNullTerminatedString(encoding);\n    }\n    if (isSet('PLUGIN_AUTH')) {\n      args.authPluginName = packet.readNullTerminatedString(encoding);\n    }\n    if (isSet('CONNECT_ATTRS')) {\n      const keysLength = packet.readLengthCodedNumber(encoding);\n      const keysEnd = packet.offset + keysLength;\n      const attrs = {};\n      while (packet.offset < keysEnd) {\n        attrs[packet.readLengthCodedString(encoding)] = packet.readLengthCodedString(encoding);\n      }\n      args.connectAttributes = attrs;\n    }\n    return args;\n  }\n}\nmodule.exports = HandshakeResponse;","map":{"version":3,"names":["ClientConstants","require","CharsetToEncoding","Packet","auth41","HandshakeResponse","constructor","handshake","user","database","password","passwordSha1","authPluginData1","authPluginData2","compress","clientFlags","flags","authToken","calculateTokenFromPasswordSha","calculateToken","charsetNumber","encoding","connectAttributes","serializeResponse","buffer","isSet","flag","packet","length","offset","writeInt32","writeInt8","skip","writeNullTerminatedString","k","writeLengthCodedNumber","writeBuffer","attrNames","Object","keys","keysLength","lengthCodedStringLength","writeLengthCodedString","toPacket","Error","p","MockBuffer","Buffer","alloc","fromPacket","args","readInt32","maxPacketSize","readInt8","readNullTerminatedString","authTokenLength","readLengthCodedNumber","readBuffer","authPluginName","keysEnd","attrs","readLengthCodedString","module","exports"],"sources":["D:/UOW_FYP/FYP1/myfoodchoice/node_modules/mysql2/lib/packets/handshake_response.js"],"sourcesContent":["'use strict';\n\nconst ClientConstants = require('../constants/client.js');\nconst CharsetToEncoding = require('../constants/charset_encodings.js');\nconst Packet = require('../packets/packet.js');\n\nconst auth41 = require('../auth_41.js');\n\nclass HandshakeResponse {\n  constructor(handshake) {\n    this.user = handshake.user || '';\n    this.database = handshake.database || '';\n    this.password = handshake.password || '';\n    this.passwordSha1 = handshake.passwordSha1;\n    this.authPluginData1 = handshake.authPluginData1;\n    this.authPluginData2 = handshake.authPluginData2;\n    this.compress = handshake.compress;\n    this.clientFlags = handshake.flags;\n    // TODO: pre-4.1 auth support\n    let authToken;\n    if (this.passwordSha1) {\n      authToken = auth41.calculateTokenFromPasswordSha(\n        this.passwordSha1,\n        this.authPluginData1,\n        this.authPluginData2\n      );\n    } else {\n      authToken = auth41.calculateToken(\n        this.password,\n        this.authPluginData1,\n        this.authPluginData2\n      );\n    }\n    this.authToken = authToken;\n    this.charsetNumber = handshake.charsetNumber;\n    this.encoding = CharsetToEncoding[handshake.charsetNumber];\n    this.connectAttributes = handshake.connectAttributes;\n  }\n\n  serializeResponse(buffer) {\n    const isSet = flag => this.clientFlags & ClientConstants[flag];\n    const packet = new Packet(0, buffer, 0, buffer.length);\n    packet.offset = 4;\n    packet.writeInt32(this.clientFlags);\n    packet.writeInt32(0); // max packet size. todo: move to config\n    packet.writeInt8(this.charsetNumber);\n    packet.skip(23);\n    const encoding = this.encoding;\n    packet.writeNullTerminatedString(this.user, encoding);\n    let k;\n    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {\n      packet.writeLengthCodedNumber(this.authToken.length);\n      packet.writeBuffer(this.authToken);\n    } else if (isSet('SECURE_CONNECTION')) {\n      packet.writeInt8(this.authToken.length);\n      packet.writeBuffer(this.authToken);\n    } else {\n      packet.writeBuffer(this.authToken);\n      packet.writeInt8(0);\n    }\n    if (isSet('CONNECT_WITH_DB')) {\n      packet.writeNullTerminatedString(this.database, encoding);\n    }\n    if (isSet('PLUGIN_AUTH')) {\n      // TODO: pass from config\n      packet.writeNullTerminatedString('mysql_native_password', 'latin1');\n    }\n    if (isSet('CONNECT_ATTRS')) {\n      const connectAttributes = this.connectAttributes || {};\n      const attrNames = Object.keys(connectAttributes);\n      let keysLength = 0;\n      for (k = 0; k < attrNames.length; ++k) {\n        keysLength += Packet.lengthCodedStringLength(attrNames[k], encoding);\n        keysLength += Packet.lengthCodedStringLength(\n          connectAttributes[attrNames[k]],\n          encoding\n        );\n      }\n      packet.writeLengthCodedNumber(keysLength);\n      for (k = 0; k < attrNames.length; ++k) {\n        packet.writeLengthCodedString(attrNames[k], encoding);\n        packet.writeLengthCodedString(\n          connectAttributes[attrNames[k]],\n          encoding\n        );\n      }\n    }\n    return packet;\n  }\n\n  toPacket() {\n    if (typeof this.user !== 'string') {\n      throw new Error('\"user\" connection config property must be a string');\n    }\n    if (typeof this.database !== 'string') {\n      throw new Error('\"database\" connection config property must be a string');\n    }\n    // dry run: calculate resulting packet length\n    const p = this.serializeResponse(Packet.MockBuffer());\n    return this.serializeResponse(Buffer.alloc(p.offset));\n  }\n  static fromPacket(packet) {\n    const args = {};\n    args.clientFlags = packet.readInt32();\n    function isSet(flag) {\n      return args.clientFlags & ClientConstants[flag];\n    }\n    args.maxPacketSize = packet.readInt32();\n    args.charsetNumber = packet.readInt8();\n    const encoding = CharsetToEncoding[args.charsetNumber];\n    args.encoding = encoding;\n    packet.skip(23);\n    args.user = packet.readNullTerminatedString(encoding);\n    let authTokenLength;\n    if (isSet('PLUGIN_AUTH_LENENC_CLIENT_DATA')) {\n      authTokenLength = packet.readLengthCodedNumber(encoding);\n      args.authToken = packet.readBuffer(authTokenLength);\n    } else if (isSet('SECURE_CONNECTION')) {\n      authTokenLength = packet.readInt8();\n      args.authToken = packet.readBuffer(authTokenLength);\n    } else {\n      args.authToken = packet.readNullTerminatedString(encoding);\n    }\n    if (isSet('CONNECT_WITH_DB')) {\n      args.database = packet.readNullTerminatedString(encoding);\n    }\n    if (isSet('PLUGIN_AUTH')) {\n      args.authPluginName = packet.readNullTerminatedString(encoding);\n    }\n    if (isSet('CONNECT_ATTRS')) {\n      const keysLength = packet.readLengthCodedNumber(encoding);\n      const keysEnd = packet.offset + keysLength;\n      const attrs = {};\n      while (packet.offset < keysEnd) {\n        attrs[\n          packet.readLengthCodedString(encoding)\n        ] = packet.readLengthCodedString(encoding);\n      }\n      args.connectAttributes = attrs;\n    }\n    return args;\n  }\n}\n\nmodule.exports = HandshakeResponse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}